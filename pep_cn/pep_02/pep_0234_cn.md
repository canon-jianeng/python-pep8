
PEP: 234
Title: Iterators
Version: $Revision$
Last-Modified: $Date$
Author: ping@zesty.ca (Ka-Ping Yee), guido@python.org (Guido van Rossum)
Status: Final
Type: Standards Track
Content-Type: text/x-rst
Created: 30-Jan-2001
Python-Version: 2.1
Post-History: 30-Apr-2001


Abstract
========

本文档提出了一个迭代接口, 对象可以提供该接口来控制 ``for`` 循环的特性.
通过提供生成迭代器对象的方法来定制循环. 迭代器提供了一个 *get next value* 操作,
每次调用时都会生成序列中的下一个项, 当没有其他项可用时引发异常.

另外, 建议在字典的键和文件的行上使用特定的迭代器,
并且建议允许拼写 ``dict.has_key(key)`` 作为 ``key in dict``.

注意: 这是第二个作者几乎完全重写此 PEP, 描述了在 Python 2.2 CVS 树的主干中检查的实际实现.
它仍然可供讨论. 在这个 PEP 的原始版本中, 一些更深奥的提议现在已被撤回;
这些可能是未来单独的 PEP 的主题.


C API Specification
===================

定义了一个新的异常, ``StopIteration``, 它可以用来表示迭代的结束.

用于请求迭代器的名为 ``tp_iter`` 的新槽被添加到类型对象结构中.
这应该是一个 ``PyObject *`` 参数的函数, 返回一个 ``PyObject *`` 或 ``NULL``.
要使用这个槽, 添加一个新的 C API 函数 ``PyObject_GetIter()``, 其签名与 ``tp_iter`` 槽函数相同.

另一个名为 ``tp_iternext`` 的新槽被添加到类型结构中, 用于获取迭代中的下一个值.
要使用此槽, 需要添加一个新的 C API 函数 ``PyIter_Next()``.
槽和 API 函数的签名如下, 尽管 ``NULL`` 返回条件不同: 参数是 ``PyObject *``,
返回值也是如此. 当返回值为非 ``NULL`` 时, 它是迭代中的下一个值.
当它是 ``NULL`` 时, 那么对于 ``tp_iternext slot``, 有三种可能性 :

- 没有异常; 这意味着迭代的结束.

- 设置 ``StopIteration`` 异常 ( 或派生异常类 ); 这意味着迭代的结束.

- 设置了其他一些异常; 这意味着发生了应该正常传播的错误.

更高级别的 ``PyIter_Next()`` 函数在发生时清除 ``StopIteration`` 异常 (或派生异常),
因此它的 ``NULL`` 返回条件更简单 :

- 没有异常; 这意味着迭代的结束.

- 设置了一些异常; 这意味着发生了错误, 应该正常传播.

在 C 中实现的迭代器应该 *不* 实现 ``next()`` 方法, 其语义与 ``tp_iternext`` 槽类似!
当类型的字典被初始化时 ( 通过 ``PyType_Ready()`` ), ``tp_iternext`` 槽的存在
导致一个方法 ``next()`` 包装该槽被添加到类型的 ``tp_dict`` 中.
( 异常: 如果类型不使用 ``PyObject_GenericGetAttr()`` 来访问实例属性,
则可能看不到类型 ``tp_dict`` 中的 ``next()`` 方法.)
( 由于误解在这个PEP的原始文本中, 在 Python 2.2 中,
所有迭代器类型都实现了一个被包装器覆盖的 ``next()`` 方法;
这在 Python 2.3 中得到了修复.)

为了确保二进制向后兼容性, 将新标志 ``Py_TPFLAGS_HAVE_ITER`` 添加到 ``tp_flags`` 字段中的标志集,
并添加到默认标志宏. 必须在访问 ``tp_iter`` 或 ``tp_iternext`` 槽之前测试此标志.
宏 ``PyIter_Check()`` 测试一个对象是否有适当的标志集并且有一个非 ``NULL`` ``tp_iternext`` 槽.
``tp_iter`` 槽没有这样的宏 (因为引用这个槽的唯一地方应该是 ``PyObject_GetIter()``,
这可以直接检查 ``Py_TPFLAGS_HAVE_ITER`` 标志).

(注意: ``tp_iter`` 槽可以出现在任何对象上; ``tp_iternext`` 槽应该仅存在于充当迭代器的对象上.)

为了向后兼容, ``PyObject_GetIter()`` 函数在其参数是一个不实现 ``tp_iter`` 函数的序列时实现回退语义:
在这种情况下构造一个轻量级序列迭代器对象, 迭代在自然顺序中的序列.

为 ``for`` 循环生成的 Python 字节码被更改为使用新的操作码, ``GET_ITER`` 和 ``FOR_ITER``,
它们使用迭代器协议而不是序列协议来获取循环变量的下一个值.
这使得可以使用 ``for`` 循环来循环支持 ``tp_iter`` 槽的非序列对象.
解释器循环遍历序列值的其他地方也应该更改为使用迭代器.

迭代器应该实现 ``tp_iter`` 槽作为返回对自己的引用; 这需要在 ``for`` 循环中使用迭代器 (而不是序列).

Iterator 实现 (在 C 或 Python 中) 应该保证一旦迭代器发出信号耗尽,
后续调用 ``tp_iternext`` 或 ``next()`` 方法将继续这样做.
当引发异常 ( 除了 ``StopIteration``) 时, 没有指定迭代器是否应该进入耗尽状态.
请注意, Python 无法保证用户定义或第三方迭代器正确实现此要求.


Python API Specification
========================

``StopIteration`` 异常作为标准异常之一可见. 它来自 ``Exception``.

定义了一个新的内置函数 ``iter()``, 它可以通过两种方式调用:

- ``iter(obj)`` 调用 ``PyObject_GetIter(obj)``.

- ``iter(callable, sentinel)`` 返回一种特殊的迭代器, 它调用 callable 来产生一个新值,
  并将返回值与 sentinel 值进行比较. 如果返回值等于 sentinel, 则表示迭代结束,
  并且 ``StopIteration`` 被提升而不是恢复正常; 如果返回值不等于 sentinel,
  则它将作为迭代器的下一个值返回. 如果 callable 引发异常, 则会正常传播;
  特别是, 该函数允许引发 ``StopIteration`` 作为结束迭代的替代方法.
  (此功能可从 C API 获得为 ``PyCallIter_New(callable, sentinel)``.）

由任何形式的 ``iter()`` 返回的迭代器对象都有一个 ``next()`` 方法.
此方法要么返回迭代中的下一个值, 要么引发 ``StopIteration`` (或派生的异常类) 来指示迭代的结束.
应该考虑任何其他异常来表示错误, 并且应该正常传播, 而不是意味着迭代的结束.

类可以通过定义 ``__iter__()`` 方法来定义迭代的方式;
这应该不需要额外的参数并返回一个有效的迭代器对象.
想要成为迭代器的类应该实现两个方法: 一个特性如上所述的 ``next()`` 方法,
以及一个返回 ``self`` 的 ``__iter__()`` 方法.

这两种方法对应于两种不同的协议:

1. 如果一个对象实现了 ``__iter__()`` 或 ``__getitem__()``, 那么可以用 ``for`` 迭代一个对象.

2. 如果一个对象实现了 ``next()``, 它就可以作为迭代器.

类容器对象通常支持协议1. 迭代器当前需要支持这两种协议.
迭代的语义只来自协议2; 协议1 的存在使得迭代器的行为类似于序列;
特别是利于接收迭代器的代码可以在迭代器上使用 for 循环.


Dictionary Iterators
====================

- 字典实现了一个 ``sq_contains`` 槽, 它实现了与 ``has_key()`` 方法相同的测试.
  这意味着我们可以写

  ::

      if k in dict: ...

  这相当于

  ::

      if dict.has_key(k): ...

- 字典实现了一个 ``tp_iter`` 槽, 它返回一个有效的迭代器, 迭代字典的键.
  在这样的迭代期间, 不应该修改字典, 除了允许设置现有键的值
  (删除或不添加, 也不是 ``update() `` 方法). 这意味着我们可以写

  ::

      for k in dict: ...

  这相当于, 但比以下方式快得多

  ::

      for k in dict.keys(): ...

  只要不违反对字典的修改 (通过循环或其他线程) 的限制.

- 向显示返回不同类型迭代器的字典添加方法::

      for key in dict.iterkeys(): ...

      for value in dict.itervalues(): ...

      for key, value in dict.iteritems(): ...

  这意味着 ``for x in dict`` 是 ``for d in dict.iterkeys()`` 的缩写.

其他映射, 如果它们完全支持迭代器, 也应该遍历键.
但是, 这不应该被视为绝对规则; 具体应用可能有不同的要求.


File Iterators
==============

以下提议很有用, 因为它为我们提供了一个很好的答案,
即对文件行重复的常用习惯是丑陋而缓慢的.

- 文件实现了一个 ``tp_iter`` 槽, 相当于 ``iter(f.readline, "")``. 这意味着我们可以写

  ::

      for line in file:
          ...

  作为简写

  ::

      for line in iter(file.readline, ""):
          ...

  这相当于, 但比以下方式更快

  ::

      while 1:
          line = file.readline()
          if not line:
              break
          ...

这也表明一些迭代器是破坏性的: 它们消耗所有值, 并且不能轻易地创建第二个迭代器,
它们在相同的值上独立迭代. 你可以第二次打开文件, 或者 ``seek()`` 到开头,
但这些解决方案不适用于所有文件类型, 例如, 当打开的文件对象真正表示管道或流套接字时, 它们不起作用.

因为文件迭代器使用内部缓冲区, 所以将它与其他文件操作 (例如, ``file.readline()``) 混合使用是行不通的.
另外, 以下代码 ::

    for line in file:
        if line == "\n":
            break
    for line in file:
       print line,

不能正常工作, 因为第二个 for 循环创建的迭代器不会考虑第一个 for 循环的缓冲区预读.
写这个的正确方法是 ::

    it = iter(file)
    for line in it:
        if line == "\n":
            break
    for line in it:
        print line,

(这些限制的基本原理是 ``for line in file`` 应该成为迭代文件行的推荐标准方法, 这应该尽可能快.
由于迭代器中的内部缓冲区, 迭代器版本比调用 ``readline()`` 要快得多.)


Rationale
=========

如果提案的所有部分都包含在内, 则会以一致和灵活的方式解决许多问题.
它的主要优点包括以下六点:

1. 它提供了一个可扩展的迭代器接口.

2. 它允许列出迭代的性能增强.

3. 它允许对字典迭代进行大的性能增强.

4. 它允许只提供迭代的接口而不假装提供对元素的随机访问.

5. 它向后兼容所有现有的用户定义类和扩展对象, 它们模拟序列和映射,
    甚至是仅实现 {``__getitem__``, ``keys``, ``values``, ``items``} 子集的映射.

6. 它使代码迭代非序列集合更简洁和可读.


Resolved Issues
===============

以下主题已经达成共识或 BDFL 声明.

- 已经提出了两个 ``next()`` 的替代拼写但是被拒绝了: ``__next__()``,
  因为它对应于一个类型对象槽 (``tp_iternext``); 和 ``__call__()``, 因为这是唯一的操作.

  反对 ``__next__()`` 的参数: 虽然许多迭代器用于 for 循环, 但是用户代码也会直接调用 ``next()``,
  所以不得不写 ``__next__()`` 是丑陋的; 另外, 协议的可能扩展是允许 ``prev()``, ``current()``
  和 ``reset()`` 操作; 当然我们不想使用 ``__prev__()``, ``__ current__()``, ``__reset__()``.

  反对 ``__call__()`` (原始提议) 的参数: 脱离上下文, ``x()`` 不是很可读, 而 ``x.next()`` 是清楚的;
  每个特殊用途对象都希望使用 ``__call__()`` 进行最常见的操作, 造成更多的混乱.

  (回想起来, 最好选择 ``__next__()`` 并有一个新的内置 ``next(it)``, 它调用 ``it.__next__()``.
  但是, 唉, 为时已晚; 自2001年12月以来, 它已部署在 Python 2.2 中.)

- 有些人要求能够重启迭代器. 这应该通过重复调用序列上的 ``iter()`` 来处理, 而不是通过迭代器协议本身来处理.
  (另请参阅下面要求的扩展.)

- 有人质疑, 发出迭代结束信号的异常是否过于昂贵. 已经提出了几种 ``StopIteration`` 异常的替代方案:
  一个特殊值 ``End`` 表示结束信号, 一个函数 ``end()`` 来测试迭代器是否完成, 甚至重用 ``IndexError`` 异常.

  - 特殊值的问题是, 如果序列包含该特殊值, 则该序列上的循环将过早结束而不会发出任何警告.
    如果使用以 null 结尾的 C 字符串的经验没有告诉我们这可能导致的问题,
	那么想象一下 Python 内省工具将迭代所有内置名称列表的麻烦, 假设特殊的 ``End`` 值是一个内置的名字!

  - 调用 ``end()`` 函数每次迭代需要两次调用. 两个调用比一个调用和一个异常测试要昂贵得多.
    特别是在时间紧迫的 for 循环可以测试非常便宜的异常.

  - 重复使用 ``IndexError`` 可能会导致混淆, 因为它可能是一个真正的错误, 可以通过过早结束循环来掩盖.

- 有些人要求使用标准迭代器类型. 据推测, 所有迭代器都必须从这种类型派生.
  但这不是 Python 方式: 字典是映射, 因为它们支持 ``__getitem__()`` 和少数其他操作,
  而不是因为它们是从抽象映射类型派生的.

- 关于 ``if key in dict``: 毫无疑问, ``dict.has_key(x)`` 解释 ``x in dict`` 是迄今为止最有用的解释,
  可能是唯一有用的解释. 由于 ``in list`` 检查值是否存在 *x*, 而提案使 ``x in dict`` 检查键中是否存在 *x*,
  因此存在阻力. 鉴于列表和字典之间的对称性非常弱, 这个论点没有多大意义.

- 名称 ``iter()`` 是一个缩写. 建议的替代方案包括 ``iterate()``, ``traverse()``, 但这些看起来太长了.
  Python 有使用 abbrs 用于常见内置的来历, 例如 ``repr()``, ``str()``, ``len()``.

  解决方案: 它是 ``iter()``.

- 对两个不同的操作使用相同的名称 (从对象获取迭代器并为具有 sentinel 值的函数创建迭代器) 有点难看.
  我没有看到第二个操作更好的名称, 因为它们都返回迭代器, 所以很容易记住.

  解决方案: 内置 ``iter()`` 接受一个可选参数, 这是要查找的标记.

- 一旦特定的迭代器对象引发了 ``StopIteration``, 它是否也会在所有后续的 ``next()`` 调用中引发 ``StopIteration``?
  有人说要求这样做是有用的, 有人说将这个开放给个别迭代器是有用的. 注意, 对于某些迭代器实现,
  这可能需要额外的状态位 (例如, 函数包装迭代器)

  解决方案: 一旦 ``StopIteration`` 被引发, 调用 ``it.next()`` 继续引发 ``StopIteration``.

  注意: 事实上这在 Python 2.2 中没有实现; 在很多情况下, 迭代器的 ``next()`` 方法可以在一次调用时
  引发 ``StopIteration`` 但在下一次调用时不引发. 这已经在 Python 2.3 中得到了解决.

- 有人提出一个文件对象应该是它自己的迭代器, 用 ``next()`` 方法返回下一行. 这具有一定的优点,
  并且使得这个迭代器具有破坏性更加清晰. 缺点是这会使实现前一个项中提出的 "sticky StopIteration" 功能变得更加痛苦.

  解决方案: 暂时拒绝 (尽管仍有人争论这个).

- 有些人要求扩展迭代器协议, 例如: ``prev()`` 获取前一项, ``current()`` 再次获取当前项,
  ``finished()`` 来测试迭代器是否完成, 甚至可能是其他的, 比如 `` rewind()``, ``__len__()``, ``position()``.

  虽然其中一些是有用的, 但是其中许多都不能轻易地为所有迭代器类型实现而不添加任意缓冲,
  有时它们根本无法实现 (或者不合理). 例如, 迭代文件或函数时, 无法完成与反转方向有关的任何操作.
  也许可以起草一个单独的 PEP 来标准化这些操作的名称.

  解决方案: 拒绝.

- 已经进行了长时间的讨论, 关于是否

  ::

      for x in dict: ...

  应该为 *x* 指定字典的连续键, 值或项. ``if x in y`` 和 ``for x in y`` 之间的对称性表明它应该遍历键.
  许多人独立地观察到这种对称性, 甚至用于使用另一种来 "解释" 这种对称性. 这是因为对于序列,
  ``y in y`` 迭代 *y*, 将迭代值与 *x* 进行比较. 如果我们采用上述两种提议, 这也适用于字典.

  反对使 ``for x in dict`` 迭代键的论据主要来自实用性观点: 标准库的扫描表明, 对于 ``for x in dict.items()`` 作为
  ``for x in dict.keys()`` 有多少用法. ``items()`` 版本占多数. 大概使用 ``keys()`` 的许多循环使用相应的值,
  通过编写 ``dict[x]``, 所以 (争论如此) 通过使键和值都可用, 我们可以支持最大的示例数量. 虽然这是真的,
  但是我 (Guido) 发现 ``for x in dict`` 和 ``if x in dict`` 之间的对应关系太强有力了, 并且没有太多的开销来写 ``dict[x]`` 明确获取值.

  要快速迭代项, 使用 ``for key, value in dict.iteritems()``. 我把它们之间的时间区分开了

  ::

      for key in dict: dict[key]

  和

  ::

      for key, value in dict.iteritems(): pass

  并发现后者仅快7％左右.

  解决方案: 通过 BDFL 声明, ``for x in dict`` 遍历键, 字典有 ``iteritems()``, ``iterkeys()``
  和 ``itervalues()`` 返回不同的字典迭代器的特点.


Mailing Lists
=============

迭代器协议已在 SourceForge 上的邮件列表中进行了广泛讨论:

    http://lists.sourceforge.net/lists/listinfo/python-iterators

最初, 一些讨论是在雅虎进行的; 档案仍然可以访问:

    http://groups.yahoo.com/group/python-iter


Copyright
=========

This document is in the public domain.



..  
  Local Variables:  
  mode: indented-text  
  indent-tabs-mode: nil  
  End:  
