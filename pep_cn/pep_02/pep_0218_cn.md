
PEP: 218
Title: Adding a Built-In Set Object Type
Version: $Revision$
Last-Modified: $Date$
Author: gvwilson@ddj.com (Greg Wilson), python@rcn.com (Raymond Hettinger)
Status: Final
Type: Standards Track
Content-Type: text/x-rst
Created: 31-Jul-2000
Python-Version: 2.2
Post-History:


Introduction
============

此 PEP 建议将 Set 模块添加到标准 Python 库, 然后在该模块被广泛使用时使集合成为内置 Python 类型.
在解释为什么集合是可取的, 以及为什么在他们的位置使用字典的常见习语不充分之后, 我们描述了我们打算如何使用内置集合,
以及初步的 Set 模块将如何表现. 最后一节讨论了集合和集合元素的可变性 (或其他), 以及 Set 模块将实现的解决方案.


Rationale
=========

集合是一种基本的数学结构, 在算法规范中非常常用. 它们在实现中的使用频率低得多, 即使它们是 "正确的" 结构.
程序员经常使用列表, 即使列表中的排序信息无关紧要, 并且经常进行按值查找.
(大多数中型 C 程序通过 malloc'd 向量包含一些令人沮丧的开始到结束搜索, 来确定是否存在特定项目...)

程序员经常被告知他们可以将集合实现为具有 "不关心" 值的字典.
通过为它们分配 "不关心" 值, 可以将项目添加到这些 "集合" 中;
会员身份可以使用``dict.has_key``进行测试; 并且可以使用``del``删除项目.
但是, 此表示不直接支持集合上的其他主要操作 (并集, 交集和差异),
因为对于包含键/值对的字典, 它们的含义不明确.


Proposal
========

此 PEP 的长期目标是为 Python 添加内置集类型.
此类型将是无序的唯一值集合, 就像字典是键/值对的无序集合一样.

迭代和理解将用明显的方式实现, 为了::

    for x in S:

将以任意顺序逐步执行 S 的元素::

    set(x**2 for x in S)

将生成一个包含 S 中所有元素的正方形的集合,
将使用``in``和``not in``测试成员资格,
并且基本集合操作将由重载运算符的混合实现:

=============  =============================
``|``          并集
``&``          交集
``^``          对等差分
``-``          不对等差分
``== !=``      相等和不相等测试
``< <= >= >``  子集和超集测试
=============  =============================

和方法:

==================  =============================================
``S.add(x)``        将 "x" 添加到集合中.

``S.update(s)``     将序列 "s" 的所有元素添加到集合中.

``S.remove(x)``     从集合中删除 "x". 如果 "x" 不存在, 则此方法引发 "LookupError" 异常.

``S.discard(x)``    如果存在, 则从集合中删除 "x", 否则不执行任何操作.

``S.pop()``         删除并返回一个任意元素, 如果元素不存在, 则引发``LookupError``.

``S.clear()``       从该集中删除所有元素.

``S.copy()``        生成新的集合.

``s.issuperset()``  检查超集关系.

``s.issubset()``    检查子集关系.
==================  =============================================

以及两个新的内置转换功能:

================  ===============================================
``set(x)``        创建一个包含集合 "x" 元素的集合.

``frozenset(x)``  创建一个包含集合 "x" 元素的不可变集.
================  ===============================================

Notes:

1.我们建议使用按位运算符 "``|＆``" 来表示交集和并集.
  虽然 "``+``" 的并集是直观的, 但 "``*``" 的交集不是
  (很少有人猜到它正确地做了什么).

2. 我们考虑使用 "``+``" 将元素添加到集合中, 而不是 "add".
   然而, Guido van Rossum 指出 "``+``" 对于其他内置类型是对称的 (尽管 "``*``" 不是).
   使用 "add" 还可以避免该操作与 set union 之间的混淆.


Set Notation
============

PEP 最初提出``{1,2,3}``作为集合表示法, ``{-}``表示空集.
使用 Python 2.3 的``sets.py``的经验表明, 符号没有必要.
此外, 还有一些风险, 使字典不易被识别.

还考虑到支撑符号将支持集合理解; 但是, Python 2.4 提供了完全满足这种需求的生成器表达式,
并且这是一种更通用的方式. (有关生成器表达式的详细信息, 请参阅 PEP 289).

因此, Guido 裁定不会有一套固定的语法; 但是, Python 3000 可以重新讨论这个问题 (参见 PEP 3000).


History
=======

为了获得集合的经验, Python 2.3 中引入了一个纯 python 模块.
基于该实现, 在 Python 2.4 中引入了 set 和 frozenset 类型. 改进是:

* 用于 frozensets 的更好的哈希算法
* 更紧凑的 pickle 格式 (仅存储元素列表而不是字典的键值对, 值总是 "True").
* 使用``__reduce__``函数, 以便自动进行深度复制.
* BaseSet 概念已被淘汰.
* ``union_update()`` 变成了 ``update()``.
* 删除了可变和不可变集之间的自动转换.
* 删除了``_repr``方法 (需要新的``sorted()``内置函数).

Tim Peters 认为类的构造函数应该将单个序列作为参数, 并使用该序列的元素填充集合.
他的论点是, 在大多数情况下, 程序员将根据预先存在的序列创建集合, 因此这种情况应该是常见的.
但是, 这将要求用户在初始化具有已知值的集合时记住一组额外的括号::

    >>> Set((1, 2, 3, 4))       # case 1

另一方面, 来自少数新手 Python 用户 (他们都对其他语言非常有经验) 的反馈
表明人们会发现更 "自然" 的 "无括号" 语法::

    >>> Set(1, 2, 3, 4)         # case 2

最终, 我们采用了第一种策略, 其中初始化程序采用单个可迭代参数.


Mutability
==========

在这个提案中要解决的最困难的问题是集合是否应该能够包含可变元素.
字典的键必须是不可变的, 以便支持快速, 可靠的查找.
虽然要求集合元素是不可变的很容易, 但这会排除集合集 (在图形算法和其他应用程序中广泛使用).

PEP 218 的早期草稿只有一个集合类型, 但 Python 2.3 中的``sets.py``实现有两个 Set 和 ImmutableSet.
对于 Python 2.4, 新的内置类型被命名为``set``和``frozenset``, 它们稍微不那么麻烦.

"sets" 模块中实现了两个类. 可以通过添加或删除元素来修改 Set 类的实例,
并且 ImmutableSet 类被 "frozen", 具有不可更改的元素集合.
因此, ImmutableSet 可以用作字典键或设置元素, 但是不能更新.
两种类型的集都要求它们的元素是不可变的, 哈希的对象. 并行注释适用于 "set" 和 "frozenset" 内置类型.


Copyright
=========

This document has been placed in the Public Domain.



..  
  Local Variables:  
  mode: indented-text  
  indent-tabs-mode: nil  
  End:  
