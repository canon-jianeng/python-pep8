
PEP: 205
Title: Weak References
Version: $Revision$
Last-Modified: $Date$
Author: Fred L. Drake, Jr. <fdrake@acm.org>
Status: Final
Type: Standards Track
Content-Type: text/x-rst
Created:
Python-Version: 2.1
Post-History: 11-Jan-2001

Motivation
==========

Python 程序员已经注意到弱引用有两个基本应用程序: 对象缓存和减少循环引用带来的痛苦.

Caches (weak dictionaries)
--------------------------

需要允许维护表示外部状态的对象, 将单个实例映射到外部现实,
其中允许将多个实例映射到相同的外部资源将在实例之间产生维持同步的不必要的困难.
在这些情况下, 常见的习惯用法是支持实例缓存; 工厂函数用于返回新实例或现有实例.

这种方法的难点在于必须容忍两件事之一: 缓存无限制地增长, 或者需要在应用程序的其他地方显式管理缓存.
后者可能非常繁琐, 导致代码比解决手头问题所需的代码更多,
前者对于长时间运行的流程甚至是具有大量内存要求的相对较短的流程都是不可接受的.

- 无论有多少内部用户, 都需要由单个实例表示的外部对象.
  这对于表示需要整体写回磁盘的文件非常有用, 而不是为每次使用锁定和修改.

- 创建成本昂贵的对象, 但多个内部消耗者可能需要这些对象.
  与第一种情况类似, 但不一定与外部资源绑定, 也可能不是共享状态的问题.
  弱引用仅在这种情况下有用, 如果存在某种 "软" 引用的风格, 或者单个对象的用户很可能在生命周期中重叠.

Circular references
-------------------

- DOM 需要大量的循环 (到父节点和文档节点) 引用,
  但这些可以使用从每个节点到其父节点的弱字典映射来消除.
  这可能在 ``xml.dom.pulldom`` 之类的上下文中特别有用,
  允许 ``.unlink()`` 操作成为无操作.

该提案分为以下几节:

- 提出的解决方案
- 实施策略
- 可能的应用
- Python 以前的弱引用工作
- Java 中的弱引用

一份早期提案的全文作为附录列入, 因为它似乎没有在网上提供.


Aspects of the Solution Space
=============================

弱引用问题有两个不同的方面:

- 弱引用无效
- 介绍对 Python 代码的弱引用

Invalidation
------------

过去弱引用失效的方法通常取决于存储强引用并能够检查弱引用对象的所有实例,
并在它们的引用对象的引用计数变为1时使它们无效 (表示弱引用存储的引用是最后剩下的参考文献).
这样做的好处是 Python 中的内存管理机制不需要改变, 任何类型都可以被弱引用.

这种无效化方法的缺点在于它假定弱引用的管理被足够频繁地调用, 以便在合理的短时间内注意到弱引用的对象;
因为这意味着扫描某些数据结构以使引用无效, 对弱引用对象的数量为 O(N) 的操作,
对于任何弱引用的单个对象, 这都不能有效地缓冲.
这也假设应用程序调用代码来处理具有某些频率的弱引用对象, 这使得弱引用对库代码的吸引力降低.

另一种失效的方法是, 解除分配代码要知道弱引用的可能性,
并在释放对象时对弱引用管理代码进行特定调用来使所有失效.
这需要在弱引用对象的 tp_dealloc 处理程序中进行更改;
对于支持弱引用的对象, 处理程序的 "top" 需要一个额外的调用,
并且还需要一种从对象映射到该对象的弱引用链的有效方法.

Presentation
------------

将弱引用呈现给 Python 层的两种方式是作为显式引用对象,
在该引用对象上需要一些操作以便检索对底层对象的可用引用,
以及尽可能伪装成原始对象的代理对象.

当在 Python 中添加一些额外的对象 managemenet 层时, 引用对象很容易使用;
可以显式检查引用的活动性, 而不必调用对象上的操作, 并在使用无效的弱引用时捕获一些特殊异常.

但是, 许多用户赞成代理方法只是因为弱引用看起来非常像原始对象.


Proposed Solution
=================

弱引用应该能够指向任何可能具有大量内存大小 (直接或间接) 的 Python 对象,
或者保存对外部资源的引用 (数据库连接, 打开文件等).

新模块 weakref 将包含用于创建弱引用的新函数. ``weakref.ref()`` 将创建一个 "弱引用对象",
并可选择附加一个回调函数, 该函数将在对象即将完成时调用. ``weakref.mapping()`` 将创建一个 "弱字典".
第三个函数 ``weakref.proxy()`` 将创建一个与原始对象有点相似的代理对象.

如果尚未收集引用对象, 则弱引用对象将允许访问引用对象,
并确定该对象是否仍存在于内存中. 通过调用引用对象来检索引用对象.
如果指示对象不再存在, 则将返回 None.

弱字典将任意键映射到值, 但不拥有对值的引用.
最终确定值时, 将从包含此类对的所有映射中删除其为值的 (键, 值) 对.
像字典一样, 弱字典也不可用.

代理对象是弱引用, 它们尽可能地尝试像它们代理的对象一样行事. 无论底层类型如何,
代理都不可清除, 因为它们充当弱引用的能力依赖于基本的可变性,
当用作字典键时将导致失败 -- 即使在引用死亡之前计算了正确的哈希值, 结果代理不能用作字典密钥,
因为一旦引用已过期就无法进行比较, 并且字典密钥需要可比性.
在引用模具之后对代理对象的操作导致在大多数情况下引发 weakref.ReferenceError.
"is" 比较, ``type()`` 和 ``id()`` 将继续工作, 但始终引用代理而不是引用.

使用弱引用注册的回调必须接受单个参数, 该参数将是弱引用或代理对象本身.
在回调中无法访问或复活对象.


Implementation Strategy
=======================

弱引用的实现将包括必须为每个弱引用对象清除的引用容器列表.
如果引用来自弱字典, 则首先清除字典入口. 然后, 使用作为参数传递的对象调用任何关联的回调.
一旦调用了所有回调, 就会最终确定并释放该对象.

许多内置类型将参与弱引用管理, 任何扩展类型都可以选择这样做.
类型结构将包含一个附加字段, 该字段为实例结构提供一个偏移量, 该实例结构包含一个弱引用结构列表.
如果字段的值 <=0, 则对象不参与. 在这种情况下, ``weakref.ref()``, ``<weakdict>.__setitem __()``
和 ``.setdefault()``, 项赋值将引发 ``TypeError``.
如果字段的值 >0, 则可以生成新的弱引用并将其添加到列表中.

采用这种方法允许任意扩展类型参与, 而不会对数字或其他小类型进行内存命中率.

支持弱引用的标准类型包括实例, 函数以及绑定和未绑定方法.
通过在 Python 2.2 中添加类类型 ("新样式类"), 类型增加了对弱引用的支持.
如果类类型的实例具有弱引用的基类型, 类不指定 ``__slots__``,
或者类的名称为 ``__weakref__``, 则类类型的实例是弱引用的. 生成器也支持弱引用.


Possible Applications
=====================

PyGTK+ 绑定?

Tkinter -- 可以通过使用从小部件到父母的弱引用来避免循环引用.
在典型的情况下, 对象不会被丢弃, 但在释放引用之前,
对程序员调用 ``.destroy()`` 的依赖程度不会太高.
这将主要使长期运行的应用程序受益.

DOM trees.


Previous Weak Reference Work in Python
======================================

Dianne Hackborn 提出了一种叫做 "虚拟引用" 的东西.
'vref' 对象与 java.lang.ref.WeakReference 对象非常相似, 除了没有等效于失效队列.
实现 "弱字典" 与在 Java 中仅使用弱引用 (没有失效队列) 一样困难.
关于此的信息已从网上消失, 但在下面作为附录包含在内.

Marc-AndrÃ© Lemburg 的 mx.Proxy 包:

    http://www.lemburg.com/files/python/mxProxy.html

Dieter Maurer 的 weakdict 模块是用 C 和 Python 实现的.
从 Python 1.5.2a 开始, Web 页面似乎还没有更新,
所以我还不确定该实现是否与 Python 2.0 兼容.

    http://www.handshake.de/~dieter/weakdict.html

Alex Shindich 的 PyWeakReference:

    http://sourceforge.net/projects/pyweakreference/

Eric Tiedemann 有一个弱字典实现:

    http://www.hyperreal.org/~est/python/weak/


Weak References in Java
=======================

http://java.sun.com/j2se/1.3/docs/api/java/lang/ref/package-summary.html

Java 提供了三种形式的弱引用, 以及一种有趣的帮助类.
这三种形式称为 "弱", "软" 和 "虚拟" 引用.
相关类在 java.lang.ref 包中定义.

对于每种引用类型, 都有一个选项可以在内存分配器使队列无效时将引用添加到队列中.
该工具的主要目的似乎是它允许组成更大的结构以结合弱引用语义, 而不必强加额外的锁定要求.
例如, 使用此工具创建 "弱" 哈希表并不困难, 该哈希表在其他地方不再使用引用时删除键和引用.
如果没有某种通知队列来使用对象的弱引用, 则会导致哈希表所需的各种操作的执行繁琐得多.
如果存储对象的解除分配很少, 则这可能是性能瓶颈.

Java 的 "弱" 引用最像 Dianne Hackborn 的旧 vref 提议:
引用对象引用单个 Python 对象, 但不拥有对该对象的引用.
取消分配该对象时, 引用对象无效. 参考对象的用户可以轻松确定引用已失效,
或者在尝试使用引用对象时可以引发 NullObjectDereferenceError.

"软" 引用类似, 但是一旦释放了对引用对象的所有其他引用, 它们就不会失效.
"软" 引用确实拥有引用, 但如果其他地方需要内存, 则允许内存分配器释放引用对象.
目前尚不清楚这是否意味着在 ``malloc()`` 实现调用 ``sbrk()`` 或它的等价物之前释放软引用,
或者只有当 ``malloc()`` 返回 ``NULL`` 时才清除软引用.

"虚拟" 引用略有不同; 与弱引用和软引用不同, 当引用添加到其队列时, 不会清除引用.
当对象的所有虚拟引用都加入队列时, 该对象将被清除. 这可以用来保持一个对象存活,
直到执行一些额外的清理, 这需要在调用对象 ``.finalize()`` 方法之前发生.

与其他两种引用类型不同, "虚拟" 引用必须与失效队列相关联.


Appendix -- Dianne Hackborn's vref proposal (1995)
==================================================

[这已缩进并且段落重新排列, 但没有内容更改.  --Fred]

Proposal: Virtual References
----------------------------

为了部分解决有关引用计数与垃圾收集的反复讨论, 我想提出一个 Python 的扩展,
它应该有助于创建 "结构良好" 的循环图. 特别是,
它应该至少允许创建具有父级向后指针和双向链表的树而不用担心周期.

我想提出的基本机制是从现在开始的 "虚拟引用" 或 "vref".
vref 本质上是对象上的句柄, 不会增加对象的引用计数.
这意味着在对象上保持 vref 不会阻止对象被破坏.
例如, 这将允许 Python 程序员创建上述树结构,
当它不再使用时会自动销毁 -- 通过将所有父级反向引用转换为 vref,
它们不再创建引用循环, 这使树不被破坏.

为了实现这种机制, Python 核心必须确保不会引用任何不再存在的对象.
我想提出的实现涉及对当前 Python 系统的两个基本补充:

1. 一种新的 "vref" 类型, Python 程序员通过该类型创建和操作虚拟引用.
  在内部, 它基本上是一个 C 级 Python 对象, 带有指向它对象的 Python 对象的指针.
  但是, 与所有其他 Python 代码不同, 它不会更改此对象的引用计数.
  此外, 它还包括两个实现双向链表的指针, 如下所示.

2. 向基本 Python 对象添加新字段
   [``PyObject_Head`` in object.h], 它可以是 ``NULL``,
   也可以指向引用它的所有 vref 对象列表的头部.
   当 vref 对象将自身附加到另一个对象时, 它会将自身添加到此链接列表中.
   然后, 如果其上具有任何 vref 的对象被解除分配,
   则它可以遍历该列表并确保其上的所有 vref 指向某个安全值, 例如, Nothing.


这个实现应该对当前的 Python 核心产生最小的影响 -- 当没有 vref 存在时,
它应该只添加一个指向所有对象的指针, 并在每次释放一个对象时检查一个 ``NULL`` 指针.

回到 Python 语言级别, 我考虑了 vref 对象的两种可能的语义 --

Pointer semantics
-----------------

在这个模型中, vref 的特性基本上类似于 Python 级指针; 
Python 程序必须显式地取消引用 vref 来操作它引用的实际对象.

使用此模型的示例 vref 模块可以包括函数 "new";
当用作 'MyVref = vref.new(MyObject)' 时, 它返回一个新的 vref 对象,
使得 ``MyVref.object == MyObject``. 
如果 ``MyObject`` 被解除分配, ``MyVref.object`` 将变为 Nothing.

举一个具体的例子, 我们可能会介绍一些新的 C 风格语法:

* ``&`` -- 一元运算符, 在对象上创建一个 vref, 与 ``vref.new()`` 相同.
* ``*`` -- 一元运算符, 取消引用 vref, 与 ``VrefObject.object`` 相同.

然后我们可以定义::

    1.     type(&MyObject) == vref.VrefType
    2.        *(&MyObject) == MyObject
    3. (*(&MyObject)).attr == MyObject.attr
    4.          &&MyObject == Nothing
    5.           *MyObject -> exception

规则 #4 是微妙的, 但是因为我们已经制作了一个 vref (一个没有真正引用的 vref).
因此, 当内部 vref 不可避免地消失时, 外部 vref 被清除为 Nothing.

Proxy semantics
----------------

在这个模型中, Python 程序员操纵 vref 对象, 就好像她正在操纵它作为参考的对象一样.
这是通过实现 vref 来实现的, 以便将其上的所有操作重定向到其引用的对象.
使用此模型, 解除引用运算符 (*) 不再有意义; 相反, 我们只有引用运算符 (＆) 和 define::

  1.  type(&MyObject) == type(MyObject)
  2.        &MyObject == MyObject
  3. (&MyObject).attr == MyObject.attr
  4.       &&MyObject == MyObject

同样, 规则 #4 很重要 - 在这里, 外部 vref 实际上是对原始对象的引用,
而不是内部 vref. 这是因为应用于 vref 的所有操作实际上都适用于其对象,
因此创建 vref 的 vref 实际上会导致创建后者对象的 vref.

第一个指针语义的优点是它很容易实现; vref 类型非常简单,
至少需要一个属性, 对象和一个函数来创建引用.

但是, 我真的很喜欢代理语义. 它不仅减轻了 Python 程序员的负担,
而且它允许你做一些好的事情, 比如, 在使用实际对象的任何地方使用 vref.
不幸的是, 如果不是几乎不可能的话, 在当前的 Python 实现中实现它可能是一种极端的痛苦.
不过, 我确实对如何做到这一点有一些想法, 如果它看起来很有趣;
一种可能性是引入处理 vref 的新类型检查功能. 这可能是旧的 C 模块,
它们不希望 vref 简单地返回类型错误, 直到它们可以被修复.

最后, 该系统还可以提供其他一些附加功能. 对我来说似乎特别感兴趣的是
允许 Python 程序员将 "析构" 函数添加到 vref 中 - 这个 Python 函数
将在被引用的对象被释放之前立即调用, 允许 Python 程序无形地将自身附加到另一个对象和注视它消失.
这看起来很整洁, 虽然我实际上没有想出任何实际用途, 但是...... :)

-- Dianne


Copyright
=========

This document has been placed in the public domain.


..  
   Local Variables:  
   mode: indented-text  
   indent-tabs-mode: nil  
   sentence-end-double-space: t  
   fill-column: 70  
   coding: utf-8  
   End:  
