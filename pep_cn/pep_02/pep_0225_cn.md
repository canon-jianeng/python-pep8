
PEP: 225
Title: Elementwise/Objectwise Operators
Version: $Revision$
Last-Modified: $Date$
Author: hzhu@users.sourceforge.net (Huaiyu Zhu),
        gregory.lielens@fft.be (Gregory Lielens)
Status: Rejected
Type: Standards Track
Content-Type: text/x-rst
Created: 19-Sep-2000
Python-Version: 2.1
Post-History:
Resolution: https://www.python.org/dev/peps/pep-0465/#rejected-alternatives-to-adding-a-new-operator


Introduction
============

本 PEP 描述了向 Python 添加新运算符的提议, 这对于区分元素和对象操作很有用,
并总结了关于此主题的新闻组 comp.lang.python 中的讨论. 请参阅最后的 "信任和档案" 部分.
这里讨论的问题包括:

- 背景.
- 提议的运算符和实现问题的描述.
- 分析新运算符的替代方案.
- 分析替代形式.
- 兼容性问题.
- 更广泛的扩展和其他相关想法的描述.

本 PEP 的很大一部分描述了未纳入拟议扩展的想法. 提出它们是因为扩展基本上是语法糖,
因此必须权衡其采用各种可能的替代方案. 虽然许多替代方案在某些方面可能更好, 但目前的提案似乎总体上是有利的.

关于元素 - 对象操作的问题扩展到比数值计算更广泛的领域.
本文档还介绍了如何将当前提案与更广泛的未来扩展相集成.


Background
==========

Python提供了六个二进制中缀数学运算符:
``+`` ``-`` ``*`` ``/`` ``%`` ``**``
它们可以为用户定义的类重载新的语义. 然而, 对于由均匀元素组成的对象,
例如, 数值计算中的数组, 向量和矩阵, 有两种基本上不同的语义风格.
对象操作将这些对象视为多维空间中的点. 元素运算将它们视为单个元素的集合.
这两种操作通常混合在相同的公式中, 因此需要语法上的区别.

许多数值计算语言提供两组数学运算符. 例如, 在 MatLab 中,
普通的 ``op`` 用于对象操作, 而 ``.op`` 用于元素操作.
在 R 中, ``op`` 代表元素运算, 而 ``％op％`` 代表逐个对象运算.

在 Python 中, 还有其他表示方法, 其中一些已经被可用的数字包使用, 例如:

- 函数:   mul(a,b)
- 方法:     a.mul(b)
- 造型:    a.E*b (在两种类型之间做转换)

在某些方面, 这些并不像中间运算符那样充足.
稍后将显示更多细节, 但关键点是:

- 可读性: 即使对于中等复杂的公式, 中间运算符也比其他运算符更清晰.

- 熟悉: 用户熟悉普通的数学运算符.

- 实现: 新的中间运算符不会过度混乱 Python 语法.
  它们将极大地简化数字包的实现.

虽然可以将当前的数学运算符分配给一种语义, 但是根本没有足够的中间运算符来为另一种语言重载.
如果其中一个不包含普通数学运算符的符号, 也不可能在这两种风格之间保持视觉对称.


Proposed extension
==================

- 六个新的二进制中间运算符 ``~+`` ``~-`` ``~*`` ``~/`` ``~%`` ``~**`` 被添加到核心 Python 中.
  它们与现有的运算符 ``+`` ``-`` ``*`` ``/`` ``%`` ``**`` 并行.

- 六个增广赋值运算符 ``~+=`` ``~-=`` ``~*=`` ``~/=`` ``~%=`` ``~**=`` 被添加到核心 Python.
  它们与 Python 2.0 中的运算符 ``+=`` ``-=`` ``*=`` ``/=`` ``%=`` ``**=`` 并行运行.

- 运算符 ``~op`` 保留运算符 ``op`` 的语法属性, 包括优先级.

- 运算符 ``~op`` 在内置数字类型上保留运算符 ``op`` 的语义属性.

- 运算符 ``~op`` 在非数字内置类型上引发语法错误. 这是暂时的, 直到可以商定适当的行为.

- 这些运算符在类中具有重载性, 其名称前缀为 *t* (对于代字号), 而不是普通数学运算符的名称.
  例如, ``__tadd__`` 和 ``__rtadd__`` 适用于 ``〜+``, ``__add__`` 和 ``__radd__`` 适用于 ``+``.

- 与现有的运算符一样, 当左操作数不提供适当的方法时, 会调用 ``__r*__()`` 方法.

一组 ``op`` 或 ``~op`` 用于元素操作, 另一组用于对象操作,
但没有指定哪个版本的运算符代表元素或对象操作, 把决定留给应用程序.

所提出的实现是修补与标记化器, 解析器, 语法和编译器有关的若干文件,
来根据需要复制相应的现有运算符的功能. 所有新语义都将在重载它们的类中实现.

符号 ``~`` 已经在 Python 中用作一元 *按位非* 运算符.
目前不允许二元运算符. 新运算符完全向后兼容.


Prototype Implementation
========================

Greg Lielens 实现了中间 ``~op`` 作为 Python 2.0b1 源代码的补丁 [1]_.

为了让 ``~`` 成为二元运算符的一部分, 标记器会将 ``~+`` 视为一个标记.
这意味着当前有效的表达式 ``~+1`` 将被标记为 ``〜+`` ``1`` 而不是 ``~ + 1``.
解析器然后将 ``~+`` 视为 ``~+`` 的复合. 该效果对应用程序是不可见的.

关于当前补丁的说明:

- 它还不包括 ``~op =`` 运算符.

- ``~op`` 的行为与列表中的 ``op`` 相同, 而不是引发异常.

当本提案的最终版本准备就绪时, 应该修复这些问题.

- 它保留 ``xor`` 作为中间运算符, 其语义等价于::

    def __xor__(a, b):
        if not b: return a
        elif not a: return b
        else: 0

这样可以尽可能保留真实值, 否则保留左侧值.

这样做是为了使位运算符在未来可以被视为元素逻辑运算符 (见下文).


Alternatives to adding new operators
====================================

关于 comp.lang.python 和 python-dev 邮件列表的讨论探讨了许多替代方案.
这里列出了一些主要的替代方案, 使用乘法运算符作为示例.

1. 使用函数 ``mul(a,b)``.

   Advantage:

   - 不需要新的运算符.

   Disadvantage:

   - 前缀形式对于复合公式来说很麻烦.
   - 对目标用户不熟悉.
   - 对于预期用户来说太冗长了.
   - 无法使用自然优先规则.

2. 使用函数调用 ``a.mul(b)``.

   Advantage:

   - 不需要新的运算符.

   Disadvantage:

   - 两个操作数不对称.
   - 对目标用户不熟悉.
   - 对于预期用户来说太冗长了.
   - 无法使用自然优先规则.

3. 使用 *shadow classes*. 对于矩阵类定义一个可通过方法 ``.E`` 访问的投影矩阵类,
   因此, 对于矩阵 *a* 和 *b*, ``a.E*b`` 将是一个矩阵对象, 即 ``elementwise_mul(a, b)``.

   同样为可通过方法 ``.M`` 访问的数组定义投影矩阵类, 这样对于数组 *a* 和 *b*,
   ``a.M*b`` 将是一个数组, 即 ``matrixwise_mul(a, b)``.

   Advantage:

   - 不需要新的运算符.
   - 中间运算符的优点是具有正确的优先级规则.
   - 清理应用中的公式.

   Disadvantage:

   - 在当前的 Python 中很难维护, 因为普通数字不能有用户定义的类方法;
     即如果 a 是纯数, 则 ``a.E*b`` 将失败.
   - 难以实现, 因为这会干扰现有的方法调用, 例如, 用于转置的 ``.T`` 等.
   - 对象创建和方法查找的运行时开销.
   - 投影类不能替换真正的类, 因为它不返回自己的类型.
     所以需要一个带有投影 ``E`` 类的 ``M`` 类和一个带有投影 ``M`` 类的 ``E`` 类.
   - 数学家不自然.

4. 实现矩阵和元素类, 轻松转换到另一个类. 因此, 数组的矩阵运算就像 ``a.M*b.M``,
   矩阵的元素运算就像 ``a.E*b.E``. 对于错误检测, ``a.E*b.M`` 会引发异常.

   Advantage:

   - 不需要新的运算符.
   - 与具有正确优先级规则的中间表示法类似.

   Disadvantage:

   - 由于缺少用于纯数字的用户方法, 因此存在类似的困难.
   - 对象创建和方法查找的运行时开销.
   - 更混乱的公式.
   - 切换对象的特点来便于操作员变得持续.
     这在应用程序代码中引入了远程上下文依赖性, 这将非常难以维护.

5. 使用迷你解析器解析来引用字符串放置的任意扩展名编写的公式.

   Advantage:

   - 纯 Python, 没有新的运算符

   Disadvantage:

   - 实际语法在引用的字符串中, 不能自行解决问题.
   - 引入特殊语法空间.
   - 严格迷你解析器.

6. 引入单个运算符, 例如 ``@``, 用于矩阵乘法.

   Advantage:

   - 引入较少的运算符

   Disadvantage:

   - 像 ``+`` ``-`` ``**`` 这样的运算符的区别同样重要.
     它们在矩阵或面向数组的包中的含义将被颠倒 (见下文).
   - 新运算符占据一个特殊的角色.
   - 这对于更一般的对象元素问题不适用.

在这些替代方案中, 第一种和第二种在一定程度上用于当前的应用, 但发现不充分.
第三种是应用程序最喜欢的, 但它会带来巨大的实现复杂性.
第四种会使应用程序代码对上下文敏感并且难以维护. 由于当前的类型或类别拆分,
这两种替代方案也存在重大的实现困难. 第五种问题似乎造成了比解决问题更多的问题.
第六部分不包括相同的应用范围.


Alternative forms of infix operators
====================================

讨论了新的中间运算符的两种主要形式和几种次要变型:

- 括号内的形式::

    (op)
    [op]
    {op}
    <op>
    :op:
    ~op~
    %op%

- 元字符形式::

    .op
    @op
    ~op

  或者, 元字符放在运算符之后.

- 这些主题的变化不太一致. 这些被认为是不利的.
  为了完整起见, 这里列出了一些:

  - 左右分区使用 ``@/`` 和 ``/@``
  - 外部和内部乘积使用 ``[*]`` 和 ``(*)``
  - 使用单个运算符 ``@`` 进行乘法运算.

- 使用 ``__call__`` 来模拟乘法::

    a(b) or (a)(b)

在表述中选择的标准包括:

- 与现有运算符没有语法歧义.

- 实际公式中的可读性更高. 这使得括号内的形式不利. 见下面的例子.

- 在视觉上类似于现有的数学运算符.

- 语法简单, 不会阻止可能的未来扩展.

根据这些标准, 括号形式的赢家似乎是 ``{op}``.
元字符形式的明显赢家是 ``~op``.
这些比较似乎 ``〜op`` 是其中所有的最喜欢的.

一些分析如下:

- ``.op`` 形式含糊不清: ``1.+a`` 与 ``1 .+a`` 不同.
- 括号类型运算符在单独时是最有利的, 但在公式中则不是,
  因为它们干扰了对括号的可视解析来获得优先级和函数参数.
  这对于 ``(op)`` 和 ``[op]`` 来说都是如此, 而对于 ``{op}`` 和 ``<op>`` 来说稍差.

- ``<op>`` 形式有可能与 ``<`` ``>`` 和 ``=`` 混淆.

- ``@op`` 不受欢迎, 因为 ``@`` 视觉上很大 (密集, 更像是一个字母):
  ``a@+b`` 比 ``a @+ b`` 更容易读作 ``a@ + b``.

- 用于选择元字符: 已使用大多数现有 ASCII 符号.
  只有三个未使用的是 ``@`` ``$`` ``?``.


Semantics of new operators
==========================

使用任何一组运算符作为对象或元素都有令人信服的论据. 其中一些列在这里:

1. ``op`` 表示元素, ``~op`` 表示对象

   - 与 Numeric 包的当前多阵列接口兼容.
   - 与其他一些语言兼容.
   - 认为元素操作更自然.
   - 认为元素操作的使用频率更高.

2. ``op`` 表示对象, ``~op`` 表示元素

   - 与 MatPy 包的当前线性代数接口兼容.
   - 与其他一些语言兼容.
   - 认为对象操作更自然.
   - 认为对象操作的使用频率更高.
   - 与列表上运算符的当前特性兼容.
   - 允许``~``成为未来扩展中的一般 elementwise(数组元素依次的) 元字符.

人们普遍同意这一点

- 没有绝对的理由支持这一方或另一方.
- 在相当大的代码块中很容易从一个表示转换为另一个表示, 因此运算符的其他风格总是少数.
- 还有其他语义差异有利于存在面向数组和面向矩阵的包, 即使它们的运算符是统一的.
- 无论做出何种决定, 使用现有接口的代码都不应该在很长一段时间内被破坏.

因此, 如果这两组操作符的语义风格不是由核心语言决定的, 那么就不会丢失太多,
并且保留了很大的灵活性. 应用程序包负责做出最合适的选择.
对于使用相反语义的 NumPy 和 MatPy 来说已经是这种情况了.
添加新运算符不会破坏这一点. 另见下面实例中第2小节后的意见.

提出了数值精度的问题, 但如果语义留给应用程序, 那么实际的精度也应该用于应用程序.


Examples
========

以下是将使用上述各种运算符或其他表示描述的实际公式的示例.

1. 矩阵求逆公式:

   - 使用 ``op`` 表示对象, 使用 ``~op`` 表示元素::

       b = a.I - a.I * u / (c.I + v/a*u) * v / a

       b = a.I - a.I * u * (c.I + v*a.I*u).I * v * a.I

   - 使用 ``op`` 表示元素, 使用 ``~op`` 表示对象::

       b = a.I @- a.I @* u @/ (c.I @+ v@/a@*u) @* v @/ a

       b = a.I ~- a.I ~* u ~/ (c.I ~+ v~/a~*u) ~* v ~/ a

       b = a.I (-) a.I (*) u (/) (c.I (+) v(/)a(*)u) (*) v (/) a

       b = a.I [-] a.I [*] u [/] (c.I [+] v[/]a[*]u) [*] v [/] a

       b = a.I <-> a.I <*> u </> (c.I <+> v</>a<*>u) <*> v </> a

       b = a.I {-} a.I {*} u {/} (c.I {+} v{/}a{*}u) {*} v {/} a

   观察: 对于使用 ``op`` 表示对象的线性代数是可取的.

   观察: ``~op`` 类型的运算符在复杂的公式中看起来比 ``(op)``类型更好.

   - 使用命名运算符::

       b = a.I @sub a.I @mul u @div (c.I @add v @div a @mul u) @mul v @div a

       b = a.I ~sub a.I ~mul u ~div (c.I ~add v ~div a ~mul u) ~mul v ~div a

   观察: 命名运算符不适合数学公式.

2. 绘制 3d 图形

   - 使用 ``op`` 表示对象, 使用 ``~op`` 表示元素::

       z = sin(x~**2 ~+ y~**2);    plot(x,y,z)

   - 使用 ``op`` 表示元素, 使用 ``~op`` 表示对象::

       z = sin(x**2 + y**2);   plot(x,y,z)

   观察: 使用广播的元素化操作允许比 MatLab 更有效的实现.

   观察: 有两个相关的类, 其中 ``op`` 和 ``~op`` 的语义交换是很有用的.
   使用这些 ``~op`` 操作符只需要出现在其他风格占主导地位的代码块中, 同时保持代码的语义兼容.

3. 使用 ``+`` 和 ``-`` 进行自动广播::

    a = b - c;  d = a.T*a

   观察: 如果 *b* 或 *c* 中的一个是行向量, 而另一个是列向量, 这将默默地产生难以跟踪的错误.


Miscellaneous issues
====================

- 需要 ``~+`` ``~-`` 运算符. 客观的 ``+`` ``-`` 很重要,
  因为它们根据线性代数提供了重要的健全性检查.
  元素 ``+`` ``-`` 很重要, 因为它们允许在应用程序中非常有效的广播.

- 左除法 (solve). 对于矩阵, ``a*x`` 不一定等于 ``x*a``. 因此 ``a*x==b`` 的解决方案,
  即 ``x=solve(a, b)`` 与 ``x*a==b`` 的解决方案不同, 表示为 ``x=div(b, a)``.
  有关于寻找新符号来进行解决的讨论. [背景: MatLab 使用 ``b/a`` 为 ``div(b, a)``
  和 ``a\b`` 为 ``solve(a, b)``.

  人们认识到 Python 提供了一个更好的解决方案, 而不需要新的符号: ``inverse``方法 ``.I`` 可以被延迟,
  为了 ``a.I*b`` 和 ``b*aI`` 相当于 Matlab 的 ``a\b`` 和 ``b/a``.
  实现非常简单, 生成的应用程序代码也很简洁.

- 幂运算符. Python 将 ``a**b`` 用作 ``pow(a, b)`` 有两个明显的缺点:

  - 大多数数学家对于 ``a^b`` 更熟悉.
  - 它引起增广赋值运算符 ``~**=`` .

  但是, 这个问题与此处的主要问题不同.

- 附加的乘法运算符. 在(多)线性代数中使用了几种形式的乘法.
  大多数可以被视为线性代数意义上的乘法变化 (例如, Kronecker 乘积).
  但是两种形式似乎更为基础: 外在乘积和内在乘积.
  但是, 它们的规范包括索引, 也可以是索引

  - 与运算符相关联, 或
  - 与对象相关联.

  后者 (爱因斯坦符号) 在文章中广泛使用, 也是更容易实现的.
  通过实现指数类张量, 一般的乘法形式将涵盖外部和内部乘积,
  并且也专注于线性代数乘法. 索引规则可以定义为类方法, 例如::

      a = b.i(1,2,-1,-2) * c.i(4,-2,3,-1)   # a_ijkl = b_ijmn c_lnkm

  因此, 一个逐项乘法就足够了.

- 按位运算符.

  - 建议的新数学运算符使用符号 ~ 即 *按位非* 运算符.
    这不会造成兼容性问题, 但实现起来有些复杂.

  - 符号 ``^`` 可能更适用于 ``pow`` 而不是按位 ``异或``.
    但这取决于按位运算符的未来. 它不会立即影响建议的数学运算符.

  - 建议使用符号 ``|`` 进行矩阵求解.
    但是使用延时的 ``.I`` 的新解决方案在个别方面更好.

  - 当前的提议适用于更大, 更通用的扩展, 这将消除对特殊按位运算符的需求. (见下面的元素化.)

- 代替定义中使用的特殊运算符名称,

  ::

      def "+"(a, b)      in place of       def __add__(a, b)

  这似乎需要更大的语法更改, 并且仅在允许任意附加运算符时才有用.


Impact on general elementization
================================

对象和元素操作之间的区别在其他上下文中也是有意义的,
其中对象在概念上可以被视为元素的集合.
重要的是, 当前的提案不排除未来可能的扩展.

一个通用的未来扩展是使用 ``~`` 作为元运算符来 *elementize* 给定的运算符. 这里列出了几个例子:

1. 按位运算符. 目前 Python 为按位操作分配了六个运算符: 按位与 (``&``), 按位或 (``|``), 按位异或 (``^``),
   按位取反 (``~``), 左移 (``<<``) 和右移 (``>>``), 具有自己的优先级.

   其中, ``&`` ``|`` ``^`` ``~`` 运算符可以看作是应用于整数的点运算符的元素版本, 被视为位串.::
   
       5 and 6                # 6
       5 or 6                 # 5

       5 ~and 6               # 4
       5 ~or 6                # 7

   这些可以被视为一般的元素点运算符, 不限于整数位.

   为了给 ``xor`` ``~xor`` 命名运算符, 有必要使 ``xor`` 成为保留字.

2. 列表算法.::
   
       [1, 2] + [3, 4]        # [1, 2, 3, 4]
       [1, 2] ~+ [3, 4]       # [4, 6]

       ['a', 'b'] * 2         # ['a', 'b', 'a', 'b']
       'ab' * 2               # 'abab'

       ['a', 'b'] ~* 2        # ['aa', 'bb']
       [1, 2] ~* 2            # [2, 4]

   它也与笛卡尔积兼容::

       [1,2]*[3,4]            # [(1,3),(1,4),(2,3),(2,4)]

3. 列表理解.::

       a = [1, 2]; b = [3, 4]
       ~f(a,b)                # [f(x,y) for x, y in zip(a,b)]
       ~f(a*b)                # [f(x,y) for x in a for y in b]
       a ~+ b                 # [x + y for x, y in zip(a,b)]

4. 元组生成 (Python 2.0 中的 zip 函数) ::

       [1, 2, 3], [4, 5, 6]   # ([1,2, 3], [4, 5, 6])
       [1, 2, 3]~,[4, 5, 6]   # [(1,4), (2, 5), (3,6)]

5. 使用 ``~`` 作为泛型元素元字符来替换 map ::

       ~f(a, b)               # map(f, a, b)
       ~~f(a, b)              # map(lambda *x:map(f, *x), a, b)

   更普遍,::

       def ~f(*x): return map(f, *x)
       def ~~f(*x): return map(~f, *x)
       ...

6. 元素格式运算符（带广播）::

       a = [1,2,3,4,5]
       print ["%5d "] ~% a
       a = [[1,2],[3,4]]
       print ["%5d "] ~~% a

7. 丰富的比较 ::

       [1, 2, 3]  ~< [3, 2, 1]  # [1, 0, 0]
       [1, 2, 3] ~== [3, 2, 1]  # [0, 1, 0]

8. 丰富的索引 ::

       [a, b, c, d] ~[2, 3, 1]  # [c, d, b]

9. 元组扁平化 ::

       a = (1,2);  b = (3,4)
       f(~a, ~b)                # f(1,2,3,4)

10. 复制运算符 ::

       a ~= b                   # a = b.copy()

   可以有特定级别的深层复制 ::

       a ~~= b                  # a = b.copy(2)

Notes
-----

1. 可能还有很多其他类似的情况.  这种通用方法似乎非常适合它们中的大多数,
   代替它们中的每一个的个别独立的扩展 (并行和交叉迭代, 列表理解, 丰富的比较等).

2. *elementwise* 的语义取决于应用程序. 例如, 矩阵元素从两层列表的角度来看是两个级别.
   这需要比当前提案更多的根本性改变. 无论如何, 目前的提案不会对这种性质的未来可能性产生负面影响.

请注意, 本节介绍了与当前提案兼容的未来扩展类型,
但可能会出现其他兼容性或其他问题. 它们与当前的提案无关.


Impact on named operators
=========================

讨论清楚地表明, 中间运算符在 Python 中是一种稀缺资源,
不仅在数值计算方面, 而且在其他领域也是如此.
提出了几个提议和想法, 允许以与命名函数类似的方式引入中间操作符.
我们在此表明, 目前的扩展不会对此方面的未来扩展产生负面影响.

1. 命名中间运算符.

   选择一个元字符, 比如说 ``@``, 这样对于任何标识符 ``opname``,
   组合 ``@opname`` 将是一个二进制中间运算符, 并且::

       a @opname b == opname(a,b)

   提到的其他陈述包括::

       .name ~name~ :name: (.name) %name%

   和相似的变化. 基于纯括号的运算符不能以这种方式使用.

   这需要在解析器中进行更改来识别 ``@opname``, 并将其解析为与函数调用相同的结构.
   所有这些运算符的优先级必须固定在一个级别, 因此, 实现将与保持现有数学运算符优先级的其他数学运算符不同.

   目前提议的扩展不会以任何方式限制此类形式的未来可能扩展.

2. 更一般的符号运算符.

   未来扩展的另一种形式是使用元字符和运算符符号
   (不能在除运算符之外的语法结构中使用的符号).
   假设 ``@`` 是元字符. 然后::

       a + b,    a @+ b,    a @@+ b,  a @+- b

   都将是具有优先级的运算符, 通过定义::

       def "+"(a, b)
       def "@+"(a, b)
       def "@@+"(a, b)
       def "@+-"(a, b)

   与命名运算符相比的一个优点是基于元字符或普通运算符符号的优先级的更大灵活性.
   这也允许运算符组成. 缺点是它们更像是 *line noise*.
   无论如何, 目前的提案不会影响其未来的可能性.

   当 Unicode 变得普遍可用时, 可能不需要这些类型的未来扩展.

   请注意, 本节讨论了建议的扩展与未来可能扩展的兼容性.
   这些其他扩展本身的可取性或兼容性在这里没有特别考虑.


Credits and archives
====================

讨论主要发生在2000年7月至8月的新闻组 comp.lang.python 和邮件列表 python-dev 上.
总共有几百个帖子, 大多数都可以从这两个页面中检索到 (并且搜索单词 "operator"):

   http://www.python.org/pipermail/python-list/2000-July/
   http://www.python.org/pipermail/python-list/2000-August/

贡献者的名字太多, 无法在这里提, 我只想说, 我们这里所讨论的想法相当大的比例是不是我们自己.

可能有助于讨论的几个关键帖子 (从我们的角度来看) 包括:

   http://www.python.org/pipermail/python-list/2000-July/108893.html
   http://www.python.org/pipermail/python-list/2000-July/108777.html
   http://www.python.org/pipermail/python-list/2000-July/108848.html
   http://www.python.org/pipermail/python-list/2000-July/109237.html
   http://www.python.org/pipermail/python-list/2000-July/109250.html
   http://www.python.org/pipermail/python-list/2000-July/109310.html
   http://www.python.org/pipermail/python-list/2000-July/109448.html
   http://www.python.org/pipermail/python-list/2000-July/109491.html
   http://www.python.org/pipermail/python-list/2000-July/109537.html
   http://www.python.org/pipermail/python-list/2000-July/109607.html
   http://www.python.org/pipermail/python-list/2000-July/109709.html
   http://www.python.org/pipermail/python-list/2000-July/109804.html
   http://www.python.org/pipermail/python-list/2000-July/109857.html
   http://www.python.org/pipermail/python-list/2000-July/110061.html
   http://www.python.org/pipermail/python-list/2000-July/110208.html
   http://www.python.org/pipermail/python-list/2000-August/111427.html
   http://www.python.org/pipermail/python-list/2000-August/111558.html
   http://www.python.org/pipermail/python-list/2000-August/112551.html
   http://www.python.org/pipermail/python-list/2000-August/112606.html
   http://www.python.org/pipermail/python-list/2000-August/112758.html

   http://www.python.org/pipermail/python-dev/2000-July/013243.html
   http://www.python.org/pipermail/python-dev/2000-July/013364.html
   http://www.python.org/pipermail/python-dev/2000-August/014940.html

这些是本 PEP 的早期草案:

   http://www.python.org/pipermail/python-list/2000-August/111785.html
   http://www.python.org/pipermail/python-list/2000-August/112529.html
   http://www.python.org/pipermail/python-dev/2000-August/014906.html

格雷格·威尔逊 (Greg Wilson) 有一个替代的 PEP (官方, PEP 211),
标题为 "为 Python 添加新的线性代数运算符".

它的第一个 (和当前) 版本是:

   http://www.python.org/pipermail/python-dev/2000-August/014876.html
   http://www.python.org/dev/peps/pep-0211/


Additional References
=====================

.. [1] http://MatPy.sourceforge.net/Misc/index.html



..  
  Local Variables:  
  mode: indented-text  
  indent-tabs-mode: nil  
  End:  
