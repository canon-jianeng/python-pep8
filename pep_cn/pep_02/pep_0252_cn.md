
PEP: 252
Title: Making Types Look More Like Classes
Version: $Revision$
Last-Modified: $Date$
Author: guido@python.org (Guido van Rossum)
Status: Final
Type: Standards Track
Content-Type: text/x-rst
Created: 19-Apr-2001
Python-Version: 2.2
Post-History:

Abstract
========

此 PEP 建议对类型的内省 API 进行更改, 使其看起来更像类,
并且它们的实例更像类实例. 例如, 对于大多数内置类型,
``type(x)`` 将等同于 ``x.__class__``. 当 C 是 ``x.__class__`` 时,
``x.meth(a)`` 通常相当于 ``C.meth(x, a)``, ``C.__dict__`` 包含 x 的方法和其他属性.

此 PEP 还引入了一种新方法来指定属性, 使用属性描述符或简称描述符.
描述符统一并概括了用于描述属性的几种不同的通用机制:
描述符可以描述方法, 对象结构中的类型字段或由 getter 和 setter 函数表示的通用属性.

基于通用描述符 API, 该 PEP 还引入了一种声明类方法和静态方法的方法.

[编者注: 本 PEP 中描述的思想已经整合到 Python 中.
PEP 不再准确描述实施.]


Introduction
============

Python 最古老的语言瑕疵之一是类和类型之间的差异. 例如,
您不能直接子类化字典类型, 并且用于查找对象具有哪些方法
和实例变量的内省接口对于类型和类是不同的.

修复类或类型拆分是一项很大的工作, 因为它影响了 Python 实现的许多方面.
这个 PEP 关注的是使类型的自我检查 API 看起来与类相同.
其他 PEP 将建议使类看起来更像类型, 并从内置类型继承子类;
这个 PEP 没有列出这些主题.


Introspection APIs
==================

自我检查关注于找出对象具有什么属性. Python 非常通用的 getattr/setattr API 使得无法
保证始终有一种方法来获取特定对象支持的所有属性的列表, 但实际上已经出现了两种约定,
它们几乎适用于所有对象. 我将它们称为基于类的自我检查 API 和基于类型的自我检查 API;
类 API 和类型 API 简称.

基于类的自我检查 API 主要用于类实例; 它也被 Jim Fulton 的 ExtensionClasses 使用.
它假定对象 x 的所有数据属性都存储在字典 ``x.__dict__`` 中, 并且所有方法和类变量都可以
通过检查 x 的类来找到, 写成 ``x.__class__``. 类有一个 ``__dict__`` 属性,
它产生一个包含类本身定义的方法和类变量的字典, 以及一个 ``__bases__`` 属性,
它是一个必须递归检查的基类元组. 这里有一些假设:

- 在实例字典中定义的属性覆盖由对象的类定义的属性;

- 派生类中定义的属性覆盖基类中定义的属性;

- 早期基类中的属性 (意味着在 ``__bases__`` 中较早出现) 会覆盖后续基类中的属性.

(最后两个规则通常被概括为从左到右, 深度优先的属性搜索规则.
这是经典的 Python 属性查找规则. 请注意, PEP 253 将建议更改属性查找顺序,
如果接受, 这个 PEP 也会效仿.)

大多数内置对象以一种或另一种形式支持基于类型的自我检查 API.
它使用两个特殊属性, ``__members__`` 和 ``__methods__``.
``__methods__`` 属性 (如果存在) 是对象支持的方法名称列表.
``__members__`` 属性 (如果存在) 是对象支持的数据属性名称列表.

类型 API 有时与 ``__dict__`` 结合使用, 与实例相同 (例如, 对于 Python 2.1 中的函数对象,
``f.__dict__`` 包含 f 的动态属性, 而 ``f.__members__``  列出 f 的静态定义属性的名称).

必须谨慎行事: 某些对象不会在 ``__members__`` 中列出其 "intrinsic" 属性
(如 ``__dict__`` 和 ``__doc__``), 而其他对象则如此; 有时属性名称出现在 ``__members__``
或 ``__methods__`` 中, 也出现在 ``__dict__`` 中的键中, 在这种情况下,
是否有人猜测是否使用了 ``__dict__`` 中的值.

从未仔细指定类型 API. 它是 Python 民间传说的一部分, 大多数第三方扩展都支持它,
因为它们遵循支持它的示例. 此外, 在其 tp_getattr 处理程序中使用 ``Py_FindMethod()``
或 ``PyMember_Get()`` 的任何类型都支持它, 因为这两个函数特殊情况下
属性名称 ``__methods__`` 和 ``__members__``, 个别.

Jim Fulton 的 ExtensionClasses 忽略了类型 API, 而是模拟了更强大的类 API.
在本 PEP 中, 我建议逐步淘汰类型 API, 来支持所有类型的类 API.

支持类 API 的一个论点是, 它不需要您创建实例来找出类型支持的属性;
这反过来对文档处理器很有用. 例如, 套接字模块导出 SocketType 对象,
但是这当前没有告诉我们在套接字对象上定义了哪些方法.
使用类 API, SocketType 将准确显示套接字对象的方法,
我们甚至可以提取其文档字符串, 而无需创建套接字.
(由于这是一个 C 扩展模块, 在这种情况下, 文档字符串提取的源扫描方法是不可行的.)


Specification of the class-based introspection API
==================================================

对象可能有两种属性: 静态和动态. 通过检查对象的类型或类可以知道静态属性的名称和其他属性,
可以通过 ``obj.__class__`` 或 ``type(obj)`` 访问它们.
(我可以互换地使用类型和类; 一个笨拙但描述性的术语同时适用于 "元对象".)

(XXX 静态和动态在这里使用不是很好的术语, 因为 "静态" 属性实际上可能非常动态,
并且因为它们与 C++ 或 Java 中的静态类成员无关. Barry 建议使用不可变和可变,
但是, 这些词语在略微不同的语境中已经具有精确和不同的含义, 所以我认为这仍然会令人困惑.)

动态属性的示例是类实例, 模块属性等的实例变量.
静态属性的示例是内置对象 (如列表和字典) 的方法,
以及框架和代码对象的属性 (``f.f_code``, ``c.co_filename`` 等).
当具有动态属性的对象通过其 ``__dict__`` 属性公开它们时, ``__dict__`` 是静态属性.

动态属性的名称和值通常存储在字典中, 并且此字典通常可以作为 ``obj.__dict__`` 访问.
本规范的其余部分更关注的是发现静态属性的名称和属性而不是动态属性;
通过检查 ``obj.__dict__`` 可以很容易地发现后者.

在下面的讨论中, 我区分了两种对象: 常规对象 (如列表, 整数, 函数) 和元对象.
类型和类是元对象. 元对象也是常规对象, 但我们最感兴趣的是因为
它们被常规对象的 ``__class__`` 属性 (或其他元对象的 ``__bases__`` 属性) 引用.

类自我检查 API 包含以下元素:

- 常规对象上的 ``__class__`` 和 ``__dict__`` 属性;

- 元对象上的 ``__bases__`` 和 ``__dict__`` 属性;

- 优先规则;

- 属性描述符.

总之, 这些不仅告诉我们关于元对象定义的所有属性,
而且它们还帮助我们计算给定对象的特定属性的值.

1. 常规对象的 ``__dict__`` 属性

   常规对象可能具有 ``__dict__`` 属性. 如果是这样, 这应该是一个映射
   (不一定是字典) 至少支持 ``__getitem__()``, ``keys()`` 和 ``has_key()``.
   这给出了对象的动态属性. 映射中的键给出属性名称, 相应的值给出它们的值.

   通常, 具有给定名称的属性的值与对应于该名称的值的对象相同,
   作为 ``__dict__`` 中的键. 换句话说, ``obj.__dict__['spam']`` 是 ``obj.spam``.
   (但请参阅下面的优先规则; 具有相同名称的静态属性可以覆盖字典项.)

2. 常规对象的 ``__class__`` 属性

   常规对象通常具有 ``__class__`` 属性. 如果是, 则引用元对象.
   元对象可以为常规对象定义静态属性, 它的 ``__class__``.
   这通常通过以下机制完成:

3. 元对象的 ``__dict__`` 属性

   元对象可以具有 ``__dict__`` 属性, 其形式与常规对象的 ``__dict__`` 属性相同
   (映射但不一定是字典). 如果是这样, 元对象的 ``__dict__`` 的键是相应常规对象的静态属性的名称.
   值是属性描述符; 我们稍后会解释这些. 未绑定方法是属性描述符的特例.

   因为元对象也是常规对象, 所以元对象的 ``__dict__`` 中的项对应于元对象的属性.
   但是, 可以应用某些转换, 并且基础 (参见下文) 可以定义其他动态属性.
   换句话说, ``mobj.spam`` 并不总是 ``mobj.__dict__['spam']``.
   (这个规则包含一个漏洞, 因为对于类, 如果 ``C.__dict__['spam']`` 是一个函数,
   ``C.spam`` 是一个未绑定的方法对象.)

4. 元对象的 ``__bases__`` 属性

   元对象可能具有 ``__bases__`` 属性. 如果是这样, 那应该是其他元对象的基础序列
   (不一定是元组). 不存在的 ``__bases__`` 相当于一个空的基数序列.
   在 ``__bases__`` 属性定义的元对象之间的关系中绝不能有循环;
   换句话说, ``__bases__`` 属性定义了一个有向无环图,
   弧从指向派生的元对象指向它们的基础元对象. (它不一定是树, 因为多个类可以具有相同的基类.)
   继承图中元对象的 ``__dict__`` 属性为 ``__class__`` 属性指向的常规对象提供属性描述符到
   继承树的根 (它与继承层次结构的根不同 -- 而不是相反, 在底部给出如何绘制继承树).
   首先根据优先级规则在根元对象的字典中搜索描述符, 然后在其基础中搜索描述符 (参见下一段).

5. 优先规则

   当给定常规对象的继承图中的两个元对象都定义具有相同名称的属性描述符时,
   搜索顺序由元对象决定. 这允许不同的元对象定义不同的搜索顺序. 特别是,
   经典类使用旧的从左到右的深度优先规则, 而新式类使用更高级的规则
   (请参阅 PEP 253 中的方法解析顺序部分).

   当一个动态属性 (在常规对象的 ``__dict__`` 中定义的一个) 与静态属性
   (一个由以常规对象的 ``__class__`` 为根的继承图中的元对象定义的属性) 相同时,
   如果静态属性是定义 ``__set__`` 方法的描述符, 则静态属性具有优先权 (见下文);
   否则 (如果没有 ``__set__`` 方法) 动态属性优先. 换句话说, 对于数据属性
   (具有 ``__set__`` 方法的属性), 静态定义会覆盖动态定义, 但对于其他属性, 动态覆盖静态.

   理由: 我们不能有一个简单的规则, 如 "静态覆盖动态" 或 "动态覆盖静态",
   因为一些静态属性确实覆盖了动态属性; 例如, 实例的 ``__dict__`` 中的键 ``__class__`` 被忽略,
   有利于静态定义的 ``__class__`` 指针, 但另一方面 ``inst.__dict__`` 中的大多数键覆盖了 ``inst.__ class__``.
   在描述符上存在 ``__set__`` 方法表明这是一个数据描述符. (即使是只读数据描述符也有一个 ``__set__`` 方法:
   它总是引发一个异常.) 描述符上没有 ``__set__`` 方法表明描述符对拦截赋值不感兴趣,
   然后是经典规则适用: 与方法同名的实例变量隐藏方法, 直到删除它为止.

6. 属性描述符

   这是它变得有趣的地方 -- 而且很混乱. 属性描述符 (简称描述符) 存储在元对象的 ``__dict__``
   (或其祖先之一的 ``__dict__``) 中, 有两种用途: 描述符可用于获取或设置 (常规, 非元) 对象上的相应属性值,
   它有一个额外的接口, 用于描述文档和自我检查目的的属性.

   Python 中很少有用于设计描述符接口的现有技术, 既不用于获取或设置值,
   也不用于描述属性, 除了一些简单的属性 (假设 ``__name__`` 和 ``__doc__``
   应该是合理的属性的名称和文档字符串). 我将在下面提出这样的 API.

   如果在元对象的 ``__dict__`` 中找到的对象不是属性描述符, 则向后兼容性决定了某些最小语义.
   这基本上意味着如果它是 Python 函数或未绑定方法, 则该属性是一个方法;
   否则, 它是动态数据属性的默认值. 向后兼容性还要求 (在没有 ``__setattr__`` 方法的情况下)
   分配给与方法相对应的属性是合法的, 并且这会创建一个数据属性,
   该属性遮蔽该特定实例的方法. 但是, 这些语义仅用于向后兼容常规类.

自我检查 API 是一个只读 API. 我们没有定义赋值给任何特殊属性的效果
(``__dict__``, ``__class__`` 和 ``__bases__``. 通常, 此类指配应该视为禁止.
未来的 PEP 可以为某些此类分配定义一些语义.
(特别是因为当前实例支持赋值给 ``__class__`` 和 ``__dict__``,
类支持赋值给 ``__bases__`` 和 ``__dict__``.)


Specification of the attribute descriptor API
=============================================

属性描述符可以具有以下属性. 在示例中, x 是一个对象, C 是 ``x.__class__``, ``x.meth()`` 是一个方法,
``x.ivar`` 是数据属性或实例变量. 所有属性都是可选的 -- 特定属性可能存在也可能不存在于给定描述符上.
不存在的属性意味着相应的信息不可用或未实现相应的功能.

- ``__name__``: 属性名称. 由于别名和重命名, 属性可以 (另外或排他地) 以不同的名称知道,
   但这是它诞生的名称. 例如: ``C.meth.__name__ == 'meth'``.

- ``__doc__``: 属性的文档字符串. 这可能是 None.

- ``__objclass__``: 声明此属性的类. 描述符仅适用于作为此类实例的对象
  (这包括其子类的实例). 例如: ``C.meth.__objclass__ 是 C``.

- ``__get__()``: 一个可调用一个或两个参数的函数, 用于从对象中检索属性值.
  这也称为 "绑定" 操作, 因为它可以在方法描述符的情况下返回 "绑定方法" 对象.
  第一个参数 X 是必须从中检索属性或必须绑定到的对象. 当 X 为 None 时,
  可选的第二个参数 T 应该是元对象, 绑定操作可以返回限制为 T 实例的 **unbound** 方法.
  当指定 X 和 T 时, X 应该是一个实例 T. 绑定操作返回的确切内容取决于描述符的语义;
  例如, 静态方法和类方法 (见下文) 忽略实例并改为绑定到类型.

- ``__set__()``: 两个参数的函数, 用于设置对象的属性值. 如果属性是只读的,
  则此方法可能引发 TypeError 或 "AttributeError" 异常
  (两者都是允许的, 因为历史上找到了未定义或不可设置的属性).
  例如: ``C.ivar.set(x, y) ~~ x.ivar = y``.


Static methods and class methods
================================

描述符 API 使得添加静态方法和类方法成为可能. 静态方法很容易描述:
它们的行为与 C++ 或 Java 中的静态方法非常相似. 这是一个例子::

    class C:

        def foo(x, y):
            print "staticmethod", x, y
        foo = staticmethod(foo)

    C.foo(1, 2)
    c = C()
    c.foo(1, 2)

调用 ``C.foo(1, 2)`` 和调用 ``c.foo(1, 2)`` 用两个参数调用 ``foo()``,
并打印 "staticmethod 1 2". 在 ``foo()`` 的定义中没有声明 "self",
并且在调用中不需要实例.

类声明中的 "foo = staticmethod(foo)" 行是关键元素: 这使得 ``foo()`` 成为静态方法.
内置的 ``staticmethod()`` 将其函数参数包装在一种特殊的描述符中,
``__get__()`` 方法返回原始函数不变. 如果没有这个,
标准函数对象的 ``__get__()`` 方法会为 'c.foo' 创建一个绑定方法对象,
为 'C.foo' 创建一个未绑定方法对象.

(XXX Barry 建议使用 "sharedmethod" 而不是 "staticmethod",
因为静态这个词已经在很多方面被重载了. 但是我不确定共享是否传达了正确的含义.)

类方法使用类似的模式来声明接收隐式第一个参数的方法, 该第一个参数是调用它们的 *类*.
它没有 C++ 或 Java 等价物, 并且与 Smalltalk 中的类方法不完全相同,
但可能有类似的用途. 根据 Armin Rigo 的说法, 它们类似于 Borland Pascal 方言 Delphi 中的 "虚拟类方法".
(Python 也有真正的元类, 也许在元类中定义的方法更有权使用名称 "类方法";
但我希望大多数程序员不会使用元类.) 这是一个例子::

    class C:

        def foo(cls, y):
            print "classmethod", cls, y
        foo = classmethod(foo)

    C.foo(1)
    c = C()
    c.foo(1)

调用 ``C.foo(1)`` 和调用 ``c.foo(1)`` 最后用 **两个** 参数调用 ``foo()``,
并打印 "classmethod __main__.C 1". 隐含了 ``foo()`` 的第一个参数,
它是类, 即使该方法是通过实例调用的. 现在让我们继续这个例子::

    class D(C):
        pass

    D.foo(1)
    d = D()
    d.foo(1)

这两次打印 "classmethod __main __.D 1"; 换句话说,
作为 ``foo()`` 的第一个参数传递的类是调用中涉及的类,
而不是参与定义 == ``foo()`` 的类.

But notice this::

    class E(C):
        def foo(cls, y): # override C.foo
            print "E.foo() called"
            C.foo(y)
        foo = classmethod(foo)

    E.foo(1)
    e = E()
    e.foo(1)

在这个例子中, 从 ``E.foo()`` 调用 ``C.foo()`` 将看到类 C 作为它的第一个参数,
而不是类 E. 这是预期的, 因为调用指定了, 但它强调了元类中定义的这些类方法和方法之间的区别,
其中向元方法的上调将目标类作为显式的第一个参数传递.
(如果你不明白这一点, 不要担心, 你并不孤单.) 注意调用 ``cls.foo(y)`` 会出错 -- 它会导致无限递归.
另请注意, 您不能为类方法指定显式的 'cls' 参数. 如果你想要这个 (例如 PEP 253 中的 ``__new__`` 方法需要这个),
请使用静态方法, 将类作为其显式的第一个参数.


C API
=====

XXX 以下是我写的考虑不同用户的非常粗略的文字;
我将不得不通过这个来编辑它。
XXX 它也没有详细介绍 C API.

内置类型可以通过两种方式声明特殊数据属性: 使用 struct memberlist (在 structmember.h 中定义)
或结构体 getsetlist（在descrobject.h中定义). 结构体成员列表是一个新用途的旧机制:
每个属性都有一个包含其名称的描述符记录, 一个给出其类型的枚举
(支持各种 C 类型以及 ``PyObject *``), 从一开始就有一个偏移量. 实例和只读标志.

结构体 getsetlist 机制是新的, 适用于不适合该模型的情况, 因为它们要么需要额外的检查,
要么是普通的计算属性. 这里的每个属性都有一个名称, 一个 getter C 函数指针,
一个 setter C 函数指针和一个上下文指针. 函数指针是可选的,
因此, 例如将 setter 函数指针设置为 ``NULL`` 会产生只读属性.
上下文指针旨在将辅助信息传递给通用 getter/setter 函数, 但我还没有找到它的必要性.

注意, 还有一种类似的机制来声明内置方法: 这些是 ``PyMethodDef`` 结构,
它包含一个名称和一个 C 函数指针 (以及调用约定的一些标志).

传统上, 内置类型必须定义自己的 ``tp_getattro`` 和 ``tp_setattro`` 槽函数,
来使这些属性定义起作用 (``PyMethodDef`` 和结构体 memberlist 很旧).
有一些方便的函数, 它们采用 ``PyMethodDef`` 或成员列表结构,
一个对象和一个属性名称的数组, 如果在列表中找到则返回或设置属性,
或者如果找不到则引发异常. 但是这些方便的函数必须由特定类型的 ``tp_getattro``
或 ``tp_setattro`` 方法显式调用, 并且使用 ``strcmp()`` 对数组进行线性搜索来查找数组元素描述请求的属性.

我现在有一个 brand  打击新的通用机制, 大大改善了这种情况.

- 指向 ``PyMethodDef``, memberlist, getsetlist 结构数组的指针是
  新类型对象的一部分 (``tp_methods``, ``tp_members``, ``tp_getset``).

- 在类型初始化时 (在 ``PyType_InitDict()`` 中), 对于这三个数组中的每个条目,
  创建一个描述符对象并将其放在属于该类型的字典中 (``tp_dict``).

- 描述符是非常精简的对象, 主要指向相应的结构. 实现细节是所有描述符共享相同的对象类型,
  并且鉴别器字段告诉它是什么类型的描述符 (方法, 成员或 getset).

- 正如在 PEP 252 中所解释的那样, 描述符有一个 ``get()`` 方法,
  它接受一个对象参数并返回该对象的属性; 可写属性的描述符也有一个 ``set()`` 方法,
  它接受一个对象和一个值并设置该对象的属性. 注意 ``get()`` 对象也作为方法的 ``bind()`` 操作,
  将未绑定的方法实现绑定到对象.

- 而不是提供自己的 tp_getattro 和 tp_setattro 实施, 几乎所有的内置对象,
   现在放置 ``PyObject_GenericGetAttr`` 和 (如果他们有任何可写的属性)
   ``PyObject_GenericSetAttr`` 在他们的 ``tp_getattro`` 和 ``tp_setattro`` 槽.
   (或者, 他们可以保留这些 ``NULL``, 并从默认的基础对象继承它们,
   如果它们在创建第一个实例之前安排对类型的 ``PyType_InitDict()`` 进行显式调用.)

- 在最简单的情况下, ``PyObject_GenericGetAttr()`` 只执行一次字典查找:
  它在类型的字典中查找属性名称 (obj -> ob_type -> tp_dict).
  成功后, 有两种可能: 描述符有 get 方法, 或者没有. 对于速度, get 和 set 方法是类型槽:
  ``tp_descr_get`` 和 ``tp_descr_set``. 如果 ``tp_descr_get`` 槽是非NULL, 则调用它,
  将对象作为唯一参数传递, 此调用的返回值是 getattr 操作的结果.
  如果 ``tp_descr_get`` 槽是 ``NULL``, 作为回退, 返回描述符本身 (比较不是方法而是简单值的类属性).

- ``PyObject_GenericSetAttr()`` 的工作方式非常相似, 但使用 ``tp_descr_set`` 槽并用对象和新属性值调用它;
   如果 ``tp_descr_set`` 槽是 ``NULL``, 则引发 ``AttributeError``.

- 但现在是一个更复杂的示例. 上述方法适用于大多数内置对象, 例如列表, 字符串, 数字.
  但是, 某些对象类型在每个实例中都有一个可以存储任意属性的字典. 实际上,
  当您使用类语句对现有内置类型进行子类型化时, 您会自动获得这样的字典
  (除非您使用另一个高级功能 ``__slots__`` 明确地将其关闭). 让我们称之为实例字典, 来区别于类型字典.

- 在更复杂的情况下, 存储在实例字典中的名称与存储在类型字典中的名称之间存在冲突.
  如果两个字典都有一个具有相同键的条目, 我们应该返回哪一个? 查看经典 Python 的指导,
  我发现了相互矛盾的规则: 对于类实例, 实例字典会覆盖类字典, **except** 以外的特殊属性
  (如 ``__dict__`` 和 ``__class__``) 优先于实例字典.

- 我用以下一套规则解决了这个问题, 这些规则在 ``PyObject_GenericGetAttr()`` 中实现:

  1. 查看类型字典. 如果找到 **data** 描述符, 请使用其 ``get()`` 方法来生成结果.
     这会处理特殊属性, 如 ``__dict__`` 和 ``__class__``.

  2. 查看实例字典. 如果你发现了什么, 那就是它.
     (这样可以满足通常实例字典覆盖类字典的要求.)

  3. 再次查看类型字典 (实际上, 这使用了步骤1中保存的结果). 如果找到描述符,
     请使用其 ``get()`` 方法; 如果你找到别的东西, 就是这样;
	 如果它不存在, 则引发 ``AttributeError``.

  这需要将描述符分类为数据和非数据描述符. 当前的实现非常合理地将成员和 getset 描述符
  分类为数据 (即使它们是只读的!) 和方法描述符作为非数据. 非描述符 (如函数指针或普通值)
  也被归类为非数据 (!).

- 这个方案有一个缺点: 在我认为最常见的情况下, 引用存储在实例字典中的实例变量,
  它执行两个字典查找, 而经典方案对从两个开始的属性进行快速测试下划线加上一个字典查找.
  (虽然实现可悲地构造为 ``instance_getattr()`` 调用 ``instance_getattr1()`` 调用 ``instance_getattr2()``
  最后调用 ``PyDict_GetItem()``, 下划线测试调用 ``PyString_AsString ()`` 而不是内联这个.
  我想知道如果我们不打算全力以赴, 如果优化 snot 可能不是加速 Python 2.2 的好主意.:-)

- 基准测试验证实际上这与经典实例变量查找一样快, 所以我不再担心.

- 对动态类型的修改: 步骤1和3查看类型及其所有基类的字典 (在 MRO 序列或 couse 中).


Discussion
==========

XXX


Examples
========

我们来看看列表. 在经典 Python 中,
列表的方法名称可用作列表对象的 __methods__ 属性::

    >>> [].__methods__
    ['append', 'count', 'extend', 'index', 'insert', 'pop',
    'remove', 'reverse', 'sort']
    >>>

根据新提案, __method__ 属性不再存在::

    >>> [].__methods__
    Traceback (most recent call last):
      File "<stdin>", line 1, in ?
    AttributeError: 'list' object has no attribute '__methods__'
    >>>

相反, 您可以从列表类型中获取相同的信息::

    >>> T = [].__class__
    >>> T
    <type 'list'>
    >>> dir(T)                # like T.__dict__.keys(), but sorted
    ['__add__', '__class__', '__contains__', '__eq__', '__ge__',
    '__getattr__', '__getitem__', '__getslice__', '__gt__',
    '__iadd__', '__imul__', '__init__', '__le__', '__len__',
    '__lt__', '__mul__', '__ne__', '__new__', '__radd__',
    '__repr__', '__rmul__', '__setitem__', '__setslice__', 'append',
    'count', 'extend', 'index', 'insert', 'pop', 'remove',
    'reverse', 'sort']
    >>>

新的自我检查 API 提供的信息比旧的更多: 除常规方法外,
它还显示通常通过特殊符号调用的方法, 例如.  ``__iadd__``
(``+=``), ``__len__`` (``len``), ``__ne__`` (``!=``).
您可以直接从此列表中调用任何方法::

    >>> a = ['tic', 'tac']
    >>> T.__len__(a)          # same as len(a)
    2
    >>> T.append(a, 'toe')    # same as a.append('toe')
    >>> a
    ['tic', 'tac', 'toe']
    >>>

这就像用户定义的类一样.

请注意列表中一个熟悉但令人惊讶的名称: ``__init__``.
这是 PEP 253 的范围.


Backwards compatibility
=======================

XXX


Warnings and Errors
===================

XXX


Implementation
==============

可以从 CVS 获得该 PEP 的部分实现, 作为名为 "descr-branch" 的分支.
要试验这个实现, 请继续根据 http://sourceforge.net/cvs/?group_id=5470 上的说明
从 CVS 中查看 Python, 但是将参数 "-r descr-branch" 添加到 cvs checkout 命令.
(您也可以从现有的校验开始并执行 "cvs update -r descr-branch".)
有关此处所述功能的一些示例, 请参阅文件 Lib/test/test_descr.py.

注意: 此分支中的代码超出了此 PEP;
它也是 PEP 253 (Subtyping Built-in Types) 的实验区域.


References
==========

XXX


Copyright
=========

This document has been placed in the public domain.

..  
   Local Variables:  
   mode: indented-text  
   indent-tabs-mode: nil  
   End:  
