
PEP: 238
Title: Changing the Division Operator
Version: $Revision$
Last-Modified: $Date$
Author: moshez@zadka.site.co.il (Moshe Zadka),
        guido@python.org (Guido van Rossum)
Status: Final
Type: Standards Track
Content-Type: text/x-rst
Created: 11-Mar-2001
Python-Version: 2.2
Post-History: 16-Mar-2001, 26-Jul-2001, 27-Jul-2001


Abstract
========

当前除法 (``/``) 运算符对数值参数有一个模糊的含义: 如果参数是 int 或 long,
它返回除数的数学结果的底限, 但如果参数, 它返回除法结果的合理近似值是浮点数还是复数.
这使得表达式期望浮点数或复数结果, 当不期望整数, 但可能作为输入时容易出错.

我们建议通过为不同的操作引入不同的运算符来解决这个问题: ``x/y`` 返回除法数学结果的合理近似值
("真正的除法"), ``x//y`` 返回地板除 ("地板除"). 我们称之为 x/y "经典除法" 的当前混合含义.

由于严重的向后兼容性问题, 更不用说 c.l.py 上的主要激烈争论, 我们提出以下过渡措施
(从 Python 2.2 开始):

- 经典除法仍然是 Python 2.x 系列中的默认值; 真正的除法将成为 Python 3.0 的标准.

- ``//`` 运算符可以明确地请求地板除.

- 拼写为 ``from __future__ import division`` 的未来除法语句将改变 ``/`` 运算符, 表示整个模块中的真正除法.

- 命令行选项将启用应用于 int 或 long 参数的经典除法的运行时警告; 另一个命令行选项默认使用真正除法.

- 标准库将在适当时使用未来除法语句和 ``//`` 运算符, 来完全避免经典除法.


Motivation
==========

经典的除法运算符使得很难编写应该从任意数字输入给出正确结果的数值表达式. 对于所有其他运算符,
可以写下一个公式, 如 ``x*y**2+z``, 计算结果将接近数学结果 (当然, 在数值精度的限制范围内)
 数字输入类型 (int, long, float 或 complex). 但是除法产生了一个问题:
 如果两个参数的表达式碰巧都有一个整数类型, 它就会实现地板除, 而不是真正的除法.

问题是动态类型语言所特有的: 在像 C 这样的静态类型语言中, 输入 (通常是函数参数) 将被声明为 double 或 float,
当调用传递一个整数参数时, 在调用期间它将被转换为 double 或 float.
Python 没有参数类型声明, 因此整数参数可以很容易地找到表达式.

这个问题特别有害, 因为在所有其他情况下, 整数是浮点数的完美替代: ``math.sqrt(2)``
返回与 ``math.sqrt(2.0)``, ``3.14*100`` 相同的值. 和 ``3.14*100.0`` 返回相同的值,
依次类推. 因此, 数值例程的作者可能只使用浮点数来测试他的代码, 并认为它正常工作,
并且用户可能会意外地传入整数输入值, 并得到不正确的结果.

另一种看待这种情况的方法是, 经典除法使得编写与 float 或 int 参数兼容的多态函数变得困难;
所有其他运算符已经做对了. 没有适用于 int 和 float 的算法需要在一种情况下截断除法,
而在另一种情况下截断真正的除法.

正确的解决方法是微妙的: 如果 float() 的参数可能是一个复数, 则抛出一个参数是错误的;
如果参数的符号为零, 则向参数添加 0.0 不会保留参数的符号.
没有任何缺点的唯一解决方案是将参数 (通常是第一个) 乘以 1.0.
这使 float 和 complex 的值和符号保持不变, 并将 int 和 long 转换为具有相应值的 float.

作者认为这是 Python 中的一个真正的设计错误, 它应该尽快修复. 假设 Python 的使用率将继续增长,
将这个 bug 留在语言中的成本最终将超过修复旧代码的成本 - 修复代码量的上限, 但可能是代码的数量.
受到未来 bug 的影响是无限的.

这种变化的另一个原因是希望最终统一 Python 的数字模型. 这是 PEP 228 [0]_ 的主题 (目前尚未完成).
统一的数字模型消除了大多数用户需要了解不同的数字类型. 这对初学者来说很有用,
但也会消除对高级程序员不同数字行为的担忧.  (当然, 它不会消除对数值稳定性和准确性的担忧.)

在统一的数值模型中, 不同的类型 (int, long, float, complex 和可能的其他类型, 例如新的有理类型)
主要用作存储优化, 并且在某种程度上用于指示正交属性, 例如不精确性或复杂性.
在统一模型中, 整数 1 应该与浮点数 1.0 是相同的 (除了它的不精确性), 并且两者在所有数字上下文中的特性应该相同.
显然, 在一个统一的数值模型中, 如果 ``a == b`` 和 ``c == d``, ``a/c`` 应该等于 ``b/d``
(由于四舍五入取得一些自由, 对于不精确的数字), 并且因为每个人都同意 ``1.0/2.0`` 等于 0.5,
所以 ``1/2`` 也应该等于 0.5. 同样, 由于 ``1//2`` 等于零, ``1.0//2.0`` 也应该等于零.


Variations
==========

在美学上, ``x//y`` 并不能让所有人满意, 因此提出了几种变体. 他们在这里提到:

- ``x div y``. 这将引入一个新的关键字. 由于 ``div`` 是一个流行的标识符, 这将破坏相当数量的现有代码,
  除非新关键字仅在未来的除法声明中被识别. 由于预计需要转换的大多数代码是除以整数,
  这将大大增加对除法声明的需求. 即使有未来的声明, 除非绝对必要, 否则反对添加新关键字,
  反驳了这种普遍情绪.

- ``div(x, y)``. 这使得旧代码的转换更加困难. 用 ``x//y`` 或 ``x div y`` 替换 ``x/y`` 可以用简单的查询替换来完成;
  在大多数情况下, 程序员可以很容易地验证特定模块仅适用于整数, 因此可以替换所有出现的 ``x/y``.
  (仍然需要查询替换来清除注释或字符串文字中出现的斜杠.) 用 ``div(x, y)`` 替换 ``x/y`` 将需要一个更加智能的工具,
  因为在放置 ``div(`` and ``)`` 部分之前, 必须先分析 ``/`` 左边和右边的表达式.

- ``x \ y``. 反斜杠已经是一个标记, 意思是行连续, 一般来说它暗示了对 Unix 查看的 *escape*.
  另外 (由于 Terry Reedy) 这会使得 ``eval("x\y") 更难以正确.


Alternatives
============

为了减少需要转换的旧代码的数量, 已经提出了几个备选提议.
以下是对每个提案 (或提案类别) 的简要讨论. 如果您知道 c.l.py 上讨论的替代方法,
请在此处提及, 请发送给第二个作者.

- 让 ``/`` 保持其经典语义; 为真正的除法引入 ``//``. 这仍然会在语言中留下一个破碎的运算符,
  并邀请使用破坏的特性. 它还关闭了 PEP 228 的统一数字模型的方式 [0]_.

- 让整数除法返回一个特殊的 "portmanteau" 类型, 它在整数上下文中表现为整数,
  但就像 float 上下文中的 float 一样. 这样做的问题是, 在几次操作之后, int 和 float 值可能相隔千里,
  不清楚在比较中应该使用哪个值, 当然许多上下文 (比如转换为字符串) 没有明确的整数或浮点数优先权.

- 使用指令在模块中使用特定的除法语义, 而不是将来的语句. 这使得经典除法成为该语言的永久性瑕疵,
  要求未来几代 Python 程序员意识到问题和补救措施.

- 使用 ``from __past__ import division`` 在模块中使用经典的除法语义. 这也保留了经典除法作为永久性瑕疵,
  或者至少很长一段时间 (最终过去的除法声明可能引发一个 ``ImportError``).

- 使用指令 (或其他方式) 指定为其开发特定代码段的 Python 版本. 这要求未来的 Python 解释器能够
  精确地模拟几个以前版本的 Python, 并且在同一个解释器中为多个版本执行此操作. 这太过分了.
  一个更简单的解决方案是安装多个解释器. 反对这一点的另一个论点是版本指令几乎总是过度指定:
  大多数为 Python XY 编写的代码, 适用于 Python X.(Y-1) 和 X.(Y+1), 因此将 XY 指定为比它需要更多限制的版本.
  同时, 没有办法知道代码将在哪个未来版本或过去版本中断.


API Changes
===========

在过渡阶段, 我们必须在同一个程序中支持三个除法运算符:
经典除法 (对于没有未来除法语句的模块中的 ``/``),
真正的除法 (对于带有未来除法声明的模块中的 ``/``)
和地板除 (对于 ``//``). 每个运算符有两种形式: 常规, 并作为扩充赋值运算符 (``/=`` 或 ``//=``).

与这些变体相关的名称是:

- 重载的运算符方法 ::

    __div__(), __floordiv__(), __truediv__();
    __idiv__(), __ifloordiv__(), __itruediv__().

- 摘要 API C 函数 ::

    PyNumber_Divide(), PyNumber_FloorDivide(),
    PyNumber_TrueDivide();

    PyNumber_InPlaceDivide(), PyNumber_InPlaceFloorDivide(),
    PyNumber_InPlaceTrueDivide().

- 字节码操作码 ::

    BINARY_DIVIDE, BINARY_FLOOR_DIVIDE, BINARY_TRUE_DIVIDE;
    INPLACE_DIVIDE, INPLACE_FLOOR_DIVIDE, INPLACE_TRUE_DIVIDE.

- PyNumberMethod 槽 ::

    nb_divide, nb_floor_divide, nb_true_divide,
    nb_inplace_divide, nb_inplace_floor_divide,
    nb_inplace_true_divide.

添加的 ``PyNumberMethod`` 槽在 ``tp_flags`` 中需要一个额外的标志;
这个标志将被命名为 ``Py_TPFLAGS_HAVE_NEWDIVIDE`` 并将被包含在 ``Py_TPFLAGS_DEFAULT`` 中.

真正的除法和地板除的 API 将寻找相应的槽并调用它;
当该槽为 ``NULL`` 时, 它们将引发异常. 经典除法槽没有回退.

在 Python 3.0 中, 将删除经典的除法语义;
经典的除法 API 将成为真正的除法的代名词.


Command Line Option
===================

``-Q`` 命令行选项采用一个字符串参数, 它可以带四个值: ``old``, ``warn``, ``warnall`` 或 ``new``.
在 Python 2.2 中默认为 ``old`` 但在后来的 2.x 版本中将变为 ``warn``.
``old`` 值表示经典除法运算符的特性如上所述. ``warn`` 值表示经典的除法运算符在应用于 int 或 long 时发出警告
(使用标准警告框架的 ``DeprecationWarning``). 当应用于浮点数或复数时, ``warnall`` 值也会对经典除法发出警告;
这是由下面提到的 ``fixdiv.py`` 转换脚本使用. ``new`` 值全局更改默认值, 利于 ``/`` 运算符始终被解释为真正除法.
``new`` 选项仅适用于需要真正除法的某些教育环境, 但要求学生在其所有代码中包含未来的除法声明将是一个问题.

Python 3.0 不支持此选项; Python 3.0 将始终将 ``/`` 解释为真正的除法.

(这个选项最初被提议为 ``-D``, 但结果证明它是 Jython 的现有选项, 因此 Q 是商数的标记符.
已提出其他名称, 如 ``-Qclassic``, ``-Qclassic-warn``, ``-Qtrue`` 或 ``-Qold_division`` 等;
对我来说这些看起来更加冗长, 没有多大优势. 毕竟术语中没有使用经典除法 (仅在 PEP 中),
并且在该语言中很少使用术语真正的除法 -- 仅在 ``__truediv__`` 中.


Semantics of Floor Division
===========================

地板除将在所有 Python 数字类型中实现, 并具有语义 ::

    a // b == floor(a/b)

除了结果类型将是在操作之前被强制转换为 *a* 和 *b* 的公共类型.

具体来说, 如果 *a* 和 *b* 属于同一类型, 那么 ``a//b`` 也属于那种类型.
如果输入具有不同类型, 则首先使用与所有其他算术运算符相同的规则将它们强制转换为公共类型.

特别是, 如果 *a* 和 *b* 都是 int 或 long, 结果与这些类型的经典除法具有相同的类型和值
(包括混合输入类型的情况; ``int//long`` 和 ``long//int`` 都会返回 long).

对于浮点输入, 结果是浮点数. 例如 ::

    3.5//2.0 == 1.0

对于复数, ``//`` 引发异常, 因为不允许复数的 ``floor()``.

对于用户定义的类和扩展类型, 所有语义都取决于类或类型的实现.


Semantics of True Division
==========================

int 和 long 的真正除法会将参数转换为 float, 然后应用浮点除法. 也就是说,
即使 ``2/1`` 也会返回一个 ``float(2.0)``, 而不是一个整数. 对于浮点数和复数, 它将与经典除法相同.

真正除法的 2.2 实现就像浮点类型具有无界范围一样, 因此除非数学结果的大小太大而不能表示为浮点数,
否则不会发生溢出. 例如, 在 ``x = 1L << 40000`` 之后, ``float(x)`` 引发 ``OverflowError``
(注意这在 2.2 中也是新的: 以前结果是平台相关的, 最常见的是浮点数无穷大).
但 ``x/x`` 毫无异常地返回 1.0, 而 ``x/1`` 引发 ``OverflowError``.

请注意, 对于 int 和 long 参数, 真正的除法可能会丢失信息; 这是真正除法的本质 (只要有理数不在语言中).
有意识地使用 longs 的算法应该考虑使用  ``//``, 因为 long 的真正除法保留不超过53位的精度 (在大多数平台上).

如果将一个有理类型添加到 Python 中 (参见 PEP 239 [2]_), 则 int 和 long 的真正除法应该返回一个有理数.
这避免了整数和长期丢失信息的真正除法的问题. 但在此之前, 为了保持一致性, 浮点数是真正除法的唯一选择.


The Future Division Statement
=============================

如果模块中存在 ``from __future__ import division``, 或者使用 ``-Qnew``, 则 ``/`` 和 ``/=`` 运算符被转换为真正的除法运算符;
否则他们被翻译成经典除法 (直到 Python 3.0 出现, 他们总是被翻译成真正的除法).

未来的除法声明对 ``//`` 和 ``//=`` 的识别或翻译没有影响.

有关未来陈述的一般规则, 请参见 PEP 236 [4]_.

(已经提出使用更长的短语, 如 *true_division* 或 *modern_division*. 这些似乎没有增加太多信息.)


Open Issues
===========

我们希望随着时间的推移, 这些问题将得到解决,
因为我们会收到更多反馈, 或者我们会在初始实施过程中积累更多经验.

- 有人建议调用 ``//`` 商数运算符, ``/`` 运算符调整比值运算符.
  我不确定这一点 - 因为有些人只是除法的同义词, 而比值则表示有理数, 这是错误的.
  如果避免明确性, 我更喜欢这个术语有点尴尬. 此外, 对于一些人 *商* 建议截断为零, 而不是无限,
  因为 *floor division* 明确说明.

- 有人认为, 更改默认值的命令行选项是错误的. 在错误的一侧中肯定是危险的:
   例如, 将需要 ``-Qnew`` 的第三方库包与需要 ``-Qold`` 的另一个库组合在一起是不可能的.
   但我相信 VPython 人员需要一种默认启用真正除法的方法, 而其他教育工作者可能也需要相同的方法.
   这些通常可以控制其环境中可用的库包.

- 对于必须支持所有三个 ``__div__()`` 的类, ``__floordiv__()`` 和 ``__truediv__()`` 似乎很痛苦;
  以及在 3.0 中做什么? 也许我们只需要 ``__div__()`` 和 ``__floordiv__()``,
  或者至少真正的除法应该尝试第一个 ``__truediv__()`` 和第二个 ``__div__()``.


Resolved Issues
===============

- 问题: 对于非常大的长整数, 将真正除法定义为返回浮点数会导致问题,
  因为 Python long 的范围远大于 Python 浮点数的范围.
  如果支持有理数, 此问题将消失.

  解决方案: 对于长期真正的除法, Python 使用具有本机双精度但无限范围的内部浮点类型,
  因此除非商数太大而不能表示为原生双精度, 否则不会发生 OverflowError.

- 问题: 在过渡期间, 如果长度超出范围, 可能会进行长到浮点转换来引发 ``OverflowError``.

  解决方案: 这已经实施, 但如上所述, 长期真正除法的输入量无关紧要; 只有商的大小才重要.

- 问题: Tim Peters 将确保每当返回范围内的浮点数时, 都能保证良好的精度.

  解决方案: 如果长的真正除法的商可表示为浮点数, 则它不会超过3个舍入误差:
  每个用于将输入转换为具有原始双精度但无限范围的内部浮点类型, 还有一个用于除法.
  但是, 请注意, 如果商的大小太小, 表示为本机双精度数, 则毫无异常地返回 0.0 ("默认下溢").


FAQ
===

When will Python 3.0 be released?
---------------------------------

    我们没有计划那么久, 所以我们不能肯定地说. 我们希望允许过渡至少两年.
	如果 Python 3.0 更早出现, 我们将保持 2.x 行的活跃性, 以便向后兼容,
	直到 Python 2.2 发布至少两年. 实际上, 在 Python 3.0 发布后,
	您将能够继续使用 Python 2.x 系列, 因此您可以花时间进行转换.
	站点预计同时安装 Python 2.x 和 Python 3.x.

Why isn't true division called float division?
----------------------------------------------

    因为我想保持公开可能引入有理数, 并使1/2返回有理数而不是浮点数.
	请见 PEP 239 [2]_.

Why is there a need for ``__truediv__`` and ``__itruediv__``?
-------------------------------------------------------------

    我们不想让用户定义的类成为二等公民.
    当然没有进行类型/类统一.

How do I write code that works under the classic rules as well as under the new rules without using ``//`` or a future division statement?
------------------------------------------------------------------------------------------------------------------------------------------

    使用 ``x*1.0/y`` 进行真正的除法, ``divmod(x, y)`` [0]_ 用于整数除法. 特别是后者最好隐藏在一个功能中.
	如果您确定不要期望复数, 也可以为真正的除法编写 ``float(x)/y``. 如果你知道你的整数从不是负数,
	你可以使用 ``int(x/y)`` -- 而 ``int()`` 的文档说 ``int()`` 可以舍入或截断取决于在 C 实现中,
	我们知道没有 C 实现不截断, 我们将改变 ``int()`` 的规范来保证截断.
	请注意, 经典除法 (和地板除法) 向负无穷大舍入, 而 ``int()`` 向零舍入, 为负数给出不同的答案.

How do I specify the division semantics for ``input()``, ``compile()``, ``execfile()``, ``eval()`` and ``exec``?
----------------------------------------------------------------------------------------------------------------

    它们继承了调用模块的选择. PEP 236 [4]_ 现在将此列为已解决的问题, 参考 PEP 264 [5]_.

What about code compiled by the codeop module?
----------------------------------------------

    这得到正确的处理; 请见 PEP 264 [5]_.

Will there be conversion tools or aids?
---------------------------------------

    当然. 虽然这些超出了 PEP 的范围, 但我应该指出两个将在 Python 2.2a3 中发布的简单工具:
	``Tools/scripts/finddiv.py`` 找到除法运算符 (比 ``grep /`` 更聪明一点)
	和 ``Tools/scripts/fixdiv.py`` 可以根据运行时分析生成补丁.

Why is my question not answered here?
-------------------------------------

    因为我们没有意识到这一点. 如果已在 c.l.py 上讨论并且您认为答案是普遍感兴趣的,
	请通知第二个作者. (我们没有时间或倾向于回答私人电子邮件中发送的每个问题,
	因此要求首先在 c.l.py 上讨论.)


Implementation
==============

基本上这里提到的所有内容都是在 CVS 中实现的,
并将与 Python 2.2a3 一起发布; 其中大部分已经发布了 Python 2.2a2.


References
==========

.. [0] PEP 228, 重写 Python 的数字模型
       http://www.python.org/dev/peps/pep-0228/

.. [1] PEP 237, 统一长整数和整数, Zadka,
       http://www.python.org/dev/peps/pep-0237/

.. [2] PEP 239, 将有理数类型添加到 Python, Zadka,
       http://www.python.org/dev/peps/pep-0239/

.. [3] PEP 240, 将有理数字面量添加到 Python, Zadka,
       http://www.python.org/dev/peps/pep-0240/

.. [4] PEP 236, 返回到 __future__, Peters,
       http://www.python.org/dev/peps/pep-0236/

.. [5] PEP 264, 模拟 shell 中的未来声明
       http://www.python.org/dev/peps/pep-0236/


Copyright
=========

This document has been placed in the public domain.



..  
  Local Variables:  
  mode: indented-text  
  indent-tabs-mode: nil  
  End:  
