
PEP: 253
Title: Subtyping Built-in Types
Version: $Revision$
Last-Modified: $Date$
Author: guido@python.org (Guido van Rossum)
Status: Final
Type: Standards Track
Content-Type: text/x-rst
Created: 14-May-2001
Python-Version: 2.2
Post-History:

Abstract
========

此 PEP 建议添加类型对象 API, 来允许在 C 和 Python 中创建内置类型的子类型.

[编者注: 本 PEP 中描述的思想已经整合到 Python 中.
PEP 不再准确描述实施.]


Introduction
============

传统上, Python 中的类型是静态创建的, 通过声明 PyTypeObject 类型的全局变量
并使用静态初始化程序初始化它. 类型对象中的槽描述了与 Python 解释器相关的
Python 类型的所有方面. 一些槽包含维度信息 (如实例的基本分配大小), 其他包含各种标志,
但大多数槽是指向实现各种行为的函数的指针. NULL 指针意味着该类型没有实现特定的行为;
在这种情况下, 系统可以提供默认行为或在为类型的实例调用行为时引发异常.
通常一起定义的一些函数指针集合是通过指向包含更多函数指针的附加结构的指针间接获得的.

虽然初始化 PyTypeObject 结构的细节没有这样记录, 但它们很容易从源代码中的示例中收集,
我假设读者已经非常熟悉在 C 中创建新 Python 类型的传统方法.
 
该 PEP 将介绍以下功能:

- 类型可以是其实例的工厂函数

- 类型可以在 C 中进行子类型化

- 可以使用 class 语句在 Python 中对类型进行子类型化

- 支持从类型的多重继承 (在实际情况下 -- 你仍然不能从列表和字典中多次继承)

- 标准的强制函数 (int, tuple, str 等) 将被重新定义为相应的类型对象,
  它们作为自己的工厂函数

- 一个类语句可以包含一个 ``__metaclass__`` 声明, 指定用于创建新类的元类

- 类语句可以包含 ``__slots__`` 声明, 指定支持的实例变量的特定名称

这个 PEP 建立在 PEP 252 之上, 它为类型增加了标准的自我检查;
例如, 当一个特定的类型对象初始化 ``tp_hash`` 槽时,
该类型对象在自我检查时具有 ``__hash__`` 方法.
PEP 252 还添加了一个字典来键入包含所有方法的对象.
在 Python 级别, 此字典对于内置类型是只读的;
在 C 级别, 它可以直接访问 (但不应该修改, 除非作为初始化的一部分).

对于二进制兼容性, tp_flags 槽中的标志位表示下面介绍的类型对象中存在各种新槽.
假设在 ``tp_flags`` 槽中没有设置 ``Py_TPFLAGS_HAVE_CLASS`` 位的类型对所有子类型槽都有 NULL 值.
(警告: 当前的实现原型在检查此标志位时, 不一致. 这应该在最终版本之前修复.)

在当前的 Python 中, 类型和类之间存在区别. 该 PEP 与 PEP 254 将消除这种区别. 但是, 为了向后兼容,
这种区别可能会在未来几年保持不变, 如果没有 PEP 254, 区别仍然很大: 类型最终具有内置类型作为基类,
而类最终来自用户定义的类. 因此, 在本 PEP 的其余部分中, 我将尽可能使用 word 类型 -- 包括基类型或超类型,
派生类型或子类型以及元类型. 但是, 有时术语必然会混合, 例如, 对象的类型由其 ``__class__`` 属性给出,
而 Python 中的子类型拼写为类声明. 如果需要进一步区分, 则可以将用户定义的类称为 "经典" 类.


About metatypes
===============

讨论不可避免地涉及元类型 (或元类). 元类型在 Python 中并不新鲜:
Python 总是能够谈论类型的类型::

    >>> a = 0
    >>> type(a)
    <type 'int'>
    >>> type(type(a))
    <type 'type'>
    >>> type(type(type(a)))
    <type 'type'>
    >>>

在这个例子中, ``type(a)`` 是一个 "常规" 类型, ``type(type(a))`` 是一个元类型.
虽然分布式所有类型都具有相同的元类型 (``PyType_Type``, 也是它自己的元类型),
但这不是必需的, 实际上一个有用且相关的第三方扩展 (由 Jim Fulton 的 ExtensionClasses)
创建了一个额外的元类型. 经典类的类型, 称为 ``types.ClassType``, 也可以被认为是一种独特的元类型.

与元类型密切相关的特性是 "Don Beaudry hook", 它表示如果元类型是可调用的,
则可以使用 Python 类语句对其实例 (常规类型) 进行子类化 (真正的子类型化).
我将使用此规则来支持内置类型的子类型, 实际上它极大地简化了类创建的逻辑,
总是简单地调用元类型. 如果未指定基类, 则调用默认元类型 -- 默认元类型为 "ClassType" 对象,
因此类语句在正常情况下的行为与以前一样. (通过设置全局变量 ``__metaclass__``,
可以为每个模块更改此默认值.)

Python 与 Smalltalk 不同的方式使用元类型或元类的概念. 在 Smalltalk-80 中,
有一个元类层次结构, 它反映了常规类的层次结构, 元类将 1-1 映射到类
(除了层次结构根部的一些有趣的业务), 每个类语句都创建一个常规类和它的元类,
将类方法放在元类中, 将实例方法放在常规类中.

虽然这可能是在 Smalltalk 的上下文中很好, 但它与 Python 中传统的元类型使用不兼容,
我更喜欢以 Python 的方式继续使用. 这意味着 Python 元类型通常用 C 语言编写,
并且可以在许多常规类型之间共享. (可以在 Python 中对子类型进行子类型化,
因此编写 C 来使用元类型不是绝对必要的; 但 Python 元类型的功能将受到限制.
例如, 永远不允许 Python 代码分配原始内存和随意初始化它.)

元类型确定类型的各种 **策略**, 例如调用类型时会发生什么, 动态类型是什么
(类型的 ``__dict__`` 是否可以在创建后修改), 方法解析顺序是什么,
如何查找实例属性, 等等.

我认为, 当你想从多重继承中获得最大的利用时, 从左到右的深度优先不是最好的解决方案.

我认为, 对于多重继承, 子类型的元类型必须是所有基类型的元类型的后代.

我稍后会回到元类型.


Making a type a factory for its instances
=========================================

传统上, 对于每种类型, 至少有一个 C 工厂函数创建该类型的实例 (``PyTuple_New()``,
``PyInt_FromLong()`` 等等. 这些工厂函数负责为对象分配内存和初始化该内存.
从 Python 2.0 开始, 它们还必须与垃圾收集子系统接口, 如果类型选择参与垃圾收集
(这是可选的, 但强烈建议用于所谓的 "容器" 类型: 可能包含对其他对象的引用的类型,
因此可参于参考周期).

在此提议中, 类型对象可以是其实例的工厂函数, 使得类型可以直接从 Python 调用.
这模仿了实例化类的方式. 用于创建各种内置类型实例的 C API 将保持有效,
并且在某些情况下更有效. 并非所有类型都将成为他们自己的工厂函数.

type 对象有一个新槽 tp_new, 它可以作为该类型实例的工厂. 类型现在是可调用的,
因为 tp_call 槽在 ``PyType_Type`` (元类型) 中设置;
该函数查找正在调用的类型的 tp_new 槽.

说明: 常规类型对象的 ``tp_call`` 槽 (例如, ``PyInt_Type`` 或 ``PyList_Type``)
定义当调用该类型的 **实例** 时会发生什么. 特别是, 函数类型中的 ``tp_call`` 槽
``PyFunction_Type`` 是使函数可调用的关键. 另一个例子是 ``PyInt_Type.tp_call`` 是 ``NULL``,
因为整数不可调用. 新示例使 **类型对象** 可调用. 由于类型对象是其元类型的实例
(``PyType_Type``), 因此元类型的 ``tp_call`` 槽 (``PyType_Type.tp_call``)
指向调用任何类型对象时调用的函数. 现在, 由于每种类型必须做一些不同的事情才能创建自己的实例,
``PyType_Type.tp_call`` 立即按照被调用类型的 ``tp_new`` 槽. ``PyType_Type`` 本身也是可调用的:
它的 ``tp_new`` 槽创建一个新类型. 这是由类声明使用 (形式化 Don Beaudry 钩子, 见上文).
是什么让 ``PyType_Type`` 可以调用? 它的元类型的 ``tp_call`` 槽 -- 但由于它是它自己的元类型,
那就是它自己的 ``tp_call`` 槽!

如果类型的 ``tp_new`` 槽为 NULL, 则引发异常.
否则, 调用 tp_new 槽. ``tp_new`` 槽的签名是

::

    PyObject *tp_new(PyTypeObject *type,
                     PyObject *args,
                     PyObject *kwds)

其中 'type' 是调用 ``tp_new`` 槽的类型, 'args' 和 'kwds' 是调用的顺序和关键字参数,
从 tp_call 传递不变. ('type' 参数与继承结合使用, 见下文.)

返回的对象类型没有约束, 但按照惯例, 它应该是给定类型的实例.
没有必要返回新对象; 对现有对象的引用也很好.
返回值应该始终是调用者拥有的新引用.

一旦 ``tp_new`` 槽返回了一个对象, 通过调用结果对象类型的 ``tp_init()`` 槽
来尝试进一步初始化, 如果不是 NULL. 这有以下签名::

     int tp_init(PyObject *self,
                 PyObject *args,
                 PyObject *kwds)

它更接近经典类的 ``__init__()`` 方法, 实际上通过 slot/special-method 对应规则映射到它.
``tp_new()`` 槽和 ``tp_init()`` 槽之间的责任差异在于它们确保的非变量.
``tp_new()`` 槽应该只保证最重要的非变量, 没有它就会破坏实现对象的 C 代码.
``tp_init()`` 槽应该用于可覆盖的用户特定初始化. 以字典类型为例.
该实现有一个指向散列表的内部指针, 该散列表永远不应该为 NULL.
这个非变量由用于字典的 ``tp_new()`` 槽来处理. 另一方面,
字典 ``tp_init()`` 槽可用于根据传入的参数为字典提供一组初始键和值。.

请注意, 对于不可变对象类型, 初始化不能通过 ``tp_init()`` 槽来完成:
这将为 Python 用户提供一种更改初始化的方法. 因此,
不可变对象通常有一个空的 ``tp_init()`` 实现, 并在 ``tp_new()`` 槽中进行所有初始化.

您可能想知道为什么 ``tp_new()`` 槽不应该调用 ``tp_init()`` 槽本身.
原因是在某些情况下 (如支持持久对象), 重要的是能够创建特定类型的对象而不必将其初始化.
这可以方便地通过调用 ``tp_new()`` 槽而不调用 ``tp_init()`` 来完成.
也可能不会调用 ``tp_init()`` 或多次调用 -- 即使在这些异常情况下它的操作也应该是健壮的.

对于某些对象, ``tp_new()`` 可能会返回一个现有对象. 例如, 整数的工厂函数缓存整数 -1 到 99.
只有当 ``tp_new()`` 的类型参数是定义 ``tp_new()`` 函数的类型时才允许这种情况 (在示例中,
如果 ``type ==＆PyInt_Type``), 当这种类型的 ``tp_init()`` 槽什么也不做.
如果类型参数不同, ``tp_new()`` 调用由派生类型的 ``tp_new()`` 启动,
来创建对象并初始化对象的基类型部分; 在这种情况下 ``tp_new()`` 应该总是返回一个新对象 (或引发异常).

``tp_new()`` 和 ``tp_init()`` 应该接收完全相同的 'args' 和 'kwds' 参数,
并且两者都应该检查参数是否可接受, 因为它们可以被独立调用.

还有第三个与对象创建相关的槽: ``tp_alloc()``. 它的职责是为对象分配内存,
初始化引用计数 (``ob_refcnt``) 和类型指针 (``ob_type``),
并将对象的其余部分初始化为全零. 如果类型支持垃圾收集,
它还应该使用垃圾收集子系统注册该对象. 存在此槽,
利于派生类型可以与初始化代码分开覆盖内存分配策略 (类似于使用哪个堆).
签名是::

    PyObject *tp_alloc(PyTypeObject *type, int nitems)

type 参数是新对象的类型. 除了具有可变分配大小的对象 (基本上是字符串, 元组和长整数) 之外,
nitems 参数通常为零. 分配大小由以下表达式给出::

    type->tp_basicsize  +  nitems * type->tp_itemsize

``tp_alloc`` 槽仅用于子类化类型. 基类的 ``tp_new()`` 函数必须
调用作为第一个参数传入的类型的 ``tp_alloc()`` 槽.
``tp_new()`` 函数负责计算项的数量. 如果 ``type-> tp_itemsize`` 成员非零,
``tp_alloc()`` 槽将设置新对象的 ob_size 成员.

(注意: 在某些调试编译模式中, 用于具有名为 ``tp_alloc`` 和 ``tp_free`` 槽的成员的
类型结构已经计算出分配和解除分配的数量. 这些被重命名为 ``tp_allocs`` 和 ``tp_deallocs``.)

可以使用 ``tp_alloc()`` 和 ``tp_new()`` 的标准实现.
``PyType_GenericAlloc()`` 从标准堆中分配一个对象并正确初始化它.
它使用上面的公式来确定要分配的内存量, 并负责 GC 注册.
不使用此实现的唯一原因是从不同的堆分配对象
(正如一些非常小的常用对象 (如整数和元组) 所做的那样).
``PyType_GenericNew()`` 添加很少: 它只调用类型的 ``tp_alloc()`` 槽,
其中 nitems 为零. 但是对于在 ``tp_init()`` 槽中进行所有初始化的可变类型,
这可能只是凭据.


Preparing a type for subtyping
==============================

子类型背后的想法与 C++ 中的单继承非常相似. 基类型由结构声明 (类似于 C++ 类声明)
和类型对象 (类似于 C++ vtable) 描述. 派生类型可以扩展结构
(但必须保持基础结构成员的名称, 顺序和类型不变), 并且可以覆盖类型对象中的某些槽,
而其他槽保持不变. (与 C++ vtable 不同, 所有 Python 类型对象都具有相同的内存布局.)

基本类型必须执行以下操作:

- 将标志值 ``Py_TPFLAGS_BASETYPE`` 添加到 ``tp_flags``.

- 声明并使用 ``tp_new()``, ``tp_alloc()`` 和可选 ``tp_init()`` 槽.

- 声明并使用 ``tp_dealloc()`` 和 ``tp_free()``.

- 导出其对象结构声明.

- 导出支持子类型的类型检查宏.

上面已经讨论过 ``tp_new()``, ``tp_alloc()`` 和 ``tp_init()`` 的要求和签名:
``tp_alloc()`` 应该分配内存并将其初始化为零; ``tp_new()`` 应该调用 ``tp_alloc()`` 槽,
然后继续进行最低限度的初始化; ``tp_init()`` 应该用于更广泛的可变对象初始化.

在对象的生命周期结束时存在类似的约定应该不足为奇. 涉及的槽是 ``tp_dealloc()``
(对所有曾经实现过 Python 扩展类型的人都很熟悉) 和 ``tp_free()``,
这是块上的新孩子. (名称不是很对称; ``tp_free()`` 对应 ``tp_alloc()``,
这很好, 但 ``tp_dealloc()`` 对应 ``tp_new()``. 也许是 tp_dealloc 槽应该重命名吗?)

应该使用 ``tp_free()`` 槽来释放内存并用垃圾收集子系统取消注册对象,
并且可以被派生类覆盖; ``tp_dealloc()`` 应该取消初始化对象
(通常通过为各种子对象调用 ``Py_XDECREF()``, 然后调用 ``tp_free()`` 来释放内存.
``tp_dealloc()`` 的签名与以往一样::

    void tp_dealloc(PyObject *object)

tp_free() 的签名是相同的::

    void tp_free(PyObject *object)

(在这个 PEP 的先前版本中, 还有一个为 ``tp_clear()`` 槽保留的角色,
这结果是个坏主意.)

要在 C 中有用地进行子类型化, 类型必须通过头文件导出其实例的结构声明,
因为它需要派生子类型. 还必须导出基类型的类型对象.

如果基类型具有类型检查宏 (如 ``PyDict_Check()``), 则应该使该宏识别子类型.
这可以通过使用新的 ``PyObject_TypeCheck(object, type)`` 宏来完成,
该宏调用跟在基类链接之后的函数.

``PyObject_TypeCheck()`` 宏包含一个小优化: 它首先将 ``object-> ob_type``
直接与 type 参数进行比较, 如果这是匹配, 则绕过函数调用.
这应该使它在大多数情况下足够快.

请注意, 类型检查宏中的此更改意味着可以使用派生类型的实例调用需要基类型实例的 C 函数.
在启用特定类型的子类型之前, 应该检查其代码来确保不会破坏任何内容. 事实证明,
在原型中为内置的 Python 对象类型添加另一个类型检查宏是有用的,
来检查确切的类型匹配 (例如, 如果 x 是一个实例, ``PyDict_Check(x)`` 是真的字典或字典子类,
而 ``PyDict_CheckExact(x)`` 只有在 x 是字典时才为真).


Creating a subtype of a built-in type in C
==========================================

最简单的子类型形式是在 C 中进行子类型化. 这是最简单的形式, 因为我们可以要求 C 代码知道一些问题,
并且对于不遵循规则来转储核心的 C 代码是可接受的. 为了增加简单性, 它仅限于单继承.

假设我们是从 tp_itemsize 为零的可变基类型派生的. 子类型代码不支持 GC,
尽管它可以从基类型继承 GC 感知 (这是自动的). 基类型的分配使用标准堆.

派生类型首先声明一个包含基类型结构的类型结构.
例如, 这是内置列表类型的子类型的类型结构::

    typedef struct {
        PyListObject list;
        int state;
    } spamlistobject;

请注意, 基类型结构成员 (此处为 ``PyListObject``) 必须是结构的第一个成员;
以下任何成员都是补充. 另请注意, 基类型不是通过指针引用的; 必须包含其结构的实际内容!
(目标是将子类型实例的开头的内存布局与基本类型实例的内存布局相同.)

接下来, 派生类型必须声明一个类型对象并初始化它. 类型对象中的大多数槽可以初始化为零,
这是必须将基本类型槽复制到其中的信号. 一些必须正确初始化的槽:

- 必须像往常一样填写对象标题; 类型应该是 ``＆PyType_Type``.

- 必须将 tp_basicsize 槽设置为子类型实例结构体的大小
  (在上面的示例中: ``sizeof(spamlistobject)``).

- 必须将 tp_base 槽设置为基类型的类型对象的地址.

- 如果派生的槽定义了任何指针成员, 那么 ``tp_dealloc`` 槽函数需要特别注意,
  见下文; 否则, 它可以设置为零, 来继承基类型的释放函数.

- 必须将 ``tp_flags`` 槽设置为通常的 ``Py_TPFLAGS_DEFAULT`` 值.

- 必须设置 ``tp_name`` 槽; 建议也设置 ``tp_doc`` (这些不是继承的).

如果子类型没有定义其他结构成员 (它只定义新行为, 没有新数据),
则 ``tp_basicsize`` 和 ``tp_dealloc`` 槽可以保留为零.

子类型的 ``tp_dealloc`` 槽值得特别注意. 如果派生类型没有定义在取消分配对象时
需要进行 DECREF 或释放的其他指针成员, 则可以将其设置为零.
否则, 子类型的 ``tp_dealloc()`` 函数必须为任何 ``PyObject *`` 成员调用 ``Py_XDECREF()``,
并为它拥有的任何其他指针调用正确的内存释放函数, 然后调用基类的 ``tp_dealloc()`` 槽.
此调用必须通过基类型的类型结构进行, 例如, 从标准列表类型派生时::

    PyList_Type.tp_dealloc(self);

如果子类型想要使用与基类型不同的分配堆, 则子类型必须覆盖 ``tp_alloc()``
和 ``tp_free()`` 槽. 这些将分别由基类的 ``tp_new()`` 和 ``tp_dealloc()`` 槽调用.

要完成类型的初始化, 必须调用 ``PyType_InitDict()``.
这将子类型中初始化为零的槽替换为相应基本类型槽的值.
(它还填写了类型字典 ``tp_dict``, 并对类型对象进行了各种其他初始化.)

在为 ``PyType_InitDict()`` 调用它之前, 子类型是不可用的; 假设子类型属于模块,
最好在模块初始化期间完成. 添加到 Python 核心 (不存在于特定模块中) 的子类型的
替代方法是在其构造函数中初始化子类型. 允许不止一次调用 ``PyType_InitDict()``;
第二次和进一步的对话都没有效果. 为了避免不必要的调用, 可以对 ``tp_dict == NULL`` 进行测试.

(在初始化 Python 解释器期间, 实际上在初始化之前使用了一些类型.
只要实际需要的槽被初始化, 特别是 ``tp_dealloc``, 这是有效的,
但它很脆弱, 不建议作为一般实践.)

要创建子类型实例, 调用子类型的 ``tp_new()`` 槽. 这应首先调用基类型的 ``tp_new()`` 槽,
然后初始化子类型的附加数据成员. 为了进一步初始化实例, 通常会调用 ``tp_init()`` 槽.
注意 ``tp_new()`` 槽应该不要调用 ``tp_init()`` 槽; 这取决于 ``tp_new()`` 的调用者
(通常是工厂函数). 在某些情况下, 不要调用 ``tp_init()``.

如果一个子类型定义了一个 ``tp_init()`` 槽, ``tp_init()`` 槽通常
应该首先调用基类型的 ``tp_init()`` 槽.

(XXX 关于在这里传递的论点应该有一两段.)


Subtyping in Python
===================

下一步是允许通过 Python 中的类语句对所选内置类型进行子类型化.
现在限于单继承, 这是一个简单的类语句::

    class C(B):
        var1 = 1
        def method1(self): pass
        # etc.

class 语句的主体在一个新环境中执行 (基本上, 一个用作本地命名空间的新字典),
然后创建 C 语言. 以下说明如何创建 C.

假设 B 是一个类型对象. 由于类型对象是对象, 并且每个对象都有一个类型,
因此 B 具有类型. 由于 B 本身就是一个类型, 我们也将其类型称为元类型.
B 的元类型可通过 ``type(B)`` 或 ``B.__class__`` 访问
(后一种表示法对于类型是新的; 它在 PEP 252 中引入).
假设这个元类型是 M (对于 Metatype). class 语句将创建一个新类型 C.
由于 C 将是一个类似 B 的类型对象, 我们将 C 的创建视为元类型的实例化 M.
需要为创建子类提供的信息是:

- 它的名字 (在这个例子中是字符串 "C");

- 它的基类 (包含 B 的单个元组);

- 以字典的形式执行类主体的结果 (例如
  ``{"var1": 1, "method1": <functionmethod1 at ...>, ...}``).

类语句将导致以下调用::

    C = M("C", (B,), dict)

其中字典是执行类体所产生的字典.
换句话说, 调用元类型 (M).

请注意, 即使示例只有一个基类, 我们仍然传入一个 (单例) 基类序列;
这使得接口与多继承情况一致.

在当前的 Python 中, 它被称为 "Don Beaudry hook", 它的创建者;
它是一种特殊情况, 仅在基类不是常规类时才会调用. 对于常规基类
(或者当没有指定基类时), 当前的 Python 调用 ``PyClass_New()``,
为类的 C 级工厂函数, 直接的.

在新系统下, 这会被更改, 利于 Python 总是确定元类型并按上面给出的方式调用它.
当给出一个或多个基类时, 第一基类的类型用作元型; 当没有给出基类时,
选择默认的元类型. 通过将默认元类型设置为 "PyClass_Type",
即 "经典" 类的元类型, 保留了类语句的经典特性.
通过设置全局变量 ``__metaclass__``, 可以为每个模块更改此默认值.

这里还有两个进一步的改进. 首先, 一个有用的功能是能够直接指定元类型.
如果类套件定义了一个变量 ``__metaclass__``, 那就是要调用的元类型.
(注意, 在模块级别设置 ``__metaclass__`` 只影响没有基类且没有明确的
``__metaclass__`` 声明的类语句; 但是在类套件中设置 ``__metaclass__``
会无条件地覆盖默认的元类型.)

其次, 对于多个基类, 并非所有基类都需要具有相同的元类型. 这被称为元类冲突 [1]_.
一些元类冲突可以通过搜索从所有其他给定元类型派生的元类型的基集来解决.
如果找不到这样的元类型, 则会引发异常并且类语句失败.

这种冲突解决方案可以由元类型构造函数实现: 类语句只调用第一个基类的元类型
(或由 ``__metaclass__`` 变量指定的元类型), 此元类型的构造函数查找大多数派生的元类型.
如果这是它自己, 它继续; 否则, 它调用元类的构造函数. 
(最后灵活性: 另一种元类型可能会选择要求所有基类具有相同的元类型, 或者只有一个基类, 或者其他类型.)

(在 [1]_ 中, 自动派生出一个新的元类, 它是所有给定元类的子类.
但是因为在 Python 中有问题的是如何合并各种元类的冲突方法定义,
我认为这不可行. 如果需要, 用户可以手动派生这样的元类,
并使用 ``__metaclass__`` 变量指定它. 也可以有一个新的元类来执行此操作.)

请注意, 调用 M 要求 M 本身具有以下类型: meta-metatype.
meta-metatype 有一种类型, 即 meta-meta-metatype. 等等.
通常通过使元类型成为其自己的元类型来在某种程度上缩短.
这确实是在 Python 中发生的事情: ``PyType_Type`` 中的 ``ob_type``
引用设置为 ``&PyType_Type``. 在没有第三方元类型的情况下,
``PyType_Type`` 是 Python 解释器中唯一的元类型.

(在此 PEP 的先前版本中, 有一个额外的元级别,
并且存在称为 "turtle" 的 meta-metatype. 这结果是不必要的.)

在任何情况下, 创建 C 的工作都是由 M 的 ``tp_new()`` 槽来完成的.
它为 "扩展" 类型结构分配空间, 包含: 类型对象; 辅助结构 (as_sequence 等);
包含类型名称的字符串对象 (来确保在类型对象仍引用它时不释放此对象);
和一些辅助存储器 (稍后描述). 它将此存储初始化为零, 除了一些关键的槽
(例如, tp_name 设置为指向类型名称), 然后将 tp_base 槽设置为指向 B.
然后调用 ``PyType_InitDict()`` 来继承 B 的槽. 最后, C 的 ``tp_dict`` 槽
用命名空间字典的内容更新 (调用 M 的第三个参数).


Multiple inheritance
====================

Python 类语句支持多重继承, 我们还将支持涉及内置类型的多重继承.

但是, 有一些限制. 除了少数退化情况之外, C 运行时体系结构不能
使两个不同内置类型的有意义的子类型可行. 更改 C 运行时来支持
完全一般的多重继承将是代码库的一个剧变.

不同内置类型的多重继承的主要问题源于内置类型的 C 实现直接访问结构成员的事实;
C 编译器生成相对于对象指针的偏移量, 就是那样. 例如, 列表和字典类型结构均声明了
许多不同但重叠的结构成员. 访问期望列表的对象的 C 函数在传递字典时将不起作用,
反之亦然, 并且我们无法做很多事情而不重写访问列表和字典的所有代码.
这将是太多的工作, 所以我们不会这样做.

多重继承的问题是由冲突的结构成员分配引起的.
Python 中定义的类通常不会将其实例变量存储在结构成员中:
它们存储在实例字典中. 这是部分解决方案的关键.
假设我们有以下两个类::

    class A(dictionary):
        def foo(self): pass

    class B(dictionary):
        def bar(self): pass

    class C(A, B): pass

(这里, '字典' 是内置字典对象的类型, 又称 ``type({})`` 或 ``{}.__class__``
或 ``types.DictType``.) 如果我们看一下在结构布局中,
我们发现 A 实例的字典布局后跟 ``__dict__`` 指针, B 实例的布局相同;
由于没有结构成员布局冲突, 这没关系.

这是另一个例子::

    class X(object):
        def foo(self): pass

    class Y(dictionary):
        def bar(self): pass

    class Z(X, Y): pass

(这里, 'object' 是所有内置类型的基础; 它的结构布局只包含 ``ob_refcnt`` 和 ``ob_type`` 成员.)
这个例子比较复杂, 因为 ``__dict__`` 指针对于 X 实例, 其偏移量与 Y 实例的偏移量不同.
Z 实例的 ``__dict__`` 指针在哪里? 答案是 ``__dict__`` 指针的偏移量不是硬编码的, 它存储在类型对象中.

假设在特定机器上, "对象" 结构长度为8个字节, "字典" 结构为60个字节,
对象指针为4个字节. 然后一个 X 结构是12个字节 (一个对象结构后跟一个 ``__dict__`` 指针),
一个 Y 结构是64个字节 (一个字典结构后跟一个 ``__dict__`` 指针). 在该示例中,
Z 结构具有与 Y 结构相同的布局. 每个类型对象 (X, Y 和 Z) 都有一个 "__dict__ offset",
用于查找 ``__dict__`` 指针. 因此, 查找实例变量的方法是:

1. 获取实例的类型
2. 从类型对象中获取 ``__dict__`` 偏移量
3. 将 ``__dict__`` 偏移添加到实例指针
4. 查看结果地址来查找字典引用
5. 在该字典中查找实例变量名称

当然, 这个方案只能在 C 中实现, 我遗漏了一些细节.
但是这允许我们使用类似于我们可以用于经典类的多个继承模式.

XXX 我应该在这里编写完整的算法来确定基类兼容性, 但我现在不能烦扰.
在下面提到的实现中查看 typeobject.c 中的 ``best_base()``.


MRO:  Method resolution order (the lookup rule)
===============================================

多重继承带来了方法解析顺序的问题:
搜索类或类型及其基类的顺序, 寻找给定名称的方法.

在经典 Python 中, 规则由以下递归函数给出,
也称为从左到右的深度优先规则::

    def classic_lookup(cls, name):
        if cls.__dict__.has_key(name):
            return cls.__dict__[name]
        for base in cls.__bases__:
            try:
                return classic_lookup(base, name)
            except AttributeError:
                pass
        raise AttributeError, name

当我们考虑 "菱形图" 时, 这个问题变得明显::

            class A:
              ^ ^  def save(self): ...
             /   \
            /     \
           /       \
          /         \
      class B     class C:
          ^         ^  def save(self): ...
           \       /
            \     /
             \   /
              \ /
            class D

箭头从一个子类型指向它的基础 ``type(s)``.
这个特定的图表意味着 B 和 C 来自 A,
而 D 来自 B 和 C (最终也是间接来自 A).

假设 C 覆盖了方法 ``save()``, 它在基类 A 中定义. (``C.save()`` 可能调用 ``A.save()``,
然后保存它自己的一些状态.) B 和 D 不会覆盖 ``save()``. 当我们在 D 实例上调用 ``save()`` 时,
调用哪个方法? 根据经典查找规则, 调用 ``A.save()``, 忽略 ``C.save()``!

不是很好. 它可能会破坏 C (它的状态不会得到保存), 从一开始就打败了继承 C 的整个目的.

为什么这不是经典 Python 中的问题? 在经典 Python 类层次结构中很少发现菱形图.
大多数类层次结构使用单继承, 多重继承通常仅限于混合类. 事实上,
这里显示的问题可能是多重继承在经典 Python 中不受欢迎的原因.

为什么这会成为新系统中的问题? 类型层次结构顶部的 "对象" 类型定义了许多可以
通过子类型有用扩展的方法, 例如 ``__getattr__()``.

(旁白: 在经典 Python 中, ``__getattr__()`` 方法实际上并不是 get-attribute 操作的实现;
它是一个只有在通过常规方法找不到属性时才会被调用的钩子.
这通常是引用作为一个缺点 -- 一些类设计有一个合法的需要 ``__getattr__()`` 方法
被调用 **所有** 属性引用. 但当然这个方法必须能够调用默认直接实现.
最自然的方法是使默认实现可用为 ``object.__getattr__(self, name)``.)

因此, 像这样的经典类层次结构::

      class B     class C:
          ^         ^  def __getattr__(self, name): ...
           \       /
            \     /
             \   /
              \ /
            class D

将在新系统下变为菱形图::

            object:
              ^ ^  __getattr__()
             /   \
            /     \
           /       \
          /         \
      class B     class C:
          ^         ^  def __getattr__(self, name): ...
           \       /
            \     /
             \   /
              \ /
            class D

而在原始图中 ``C.__getattr__()`` 被调用, 在具有经典查找规则的新系统下,
``object.__getattr__()`` 将被调用!

幸运的是, 有一个更好的查找规则. 这有点难以解释, 但它在菱形图中做了正确的事情,
并且当继承图中没有菱形时 (当它是树时) 它与经典查找规则相同.

新的查找规则按照搜索顺序构建继承图中所有类的列表. 这种结构在类定义时完成,
来节省时间. 为了解释新的查找规则, 我们首先考虑一下这样的列表对于经典查找规则的样子.
请注意, 在存在菱形的情况下, 经典查找会多次访问某些类. 例如, 在上面的 ABCD 菱形图中,
经典查找规则按此顺序访问类::

  D, B, A, C, A

请注意 A 在列表中出现两次的情况. 第二次出现是多余的,
因为在搜索第一次出现时已经找到了可以在那里找到的任何东西.

我们使用此观察来解释我们的新查找规则. 使用经典查找规则, 构造将要搜索的类列表,
包括重复项. 现在, 对于列表中多次出现的每个类, 删除除最后一个之外的所有匹配项.
结果列表只包含每个祖先类一次 (包括最多派生类, 示例中为 D).

按此顺序搜索方法将为菱形图做正确的事情. 由于列表的构造方式,
在不涉及菱形的情况下, 它不会更改搜索顺序.

这不是倒退吗? 它会破坏现有代码吗? 如果我们更改了所有类的方法解析顺序, 它会.
但是, 在 Python 2.2 中, 新的查找规则仅适用于从内置类型派生的类型, 这是一个新功能.
没有基类的类语句创建 "经典类", 基类本身就是经典类的类语句也是如此. 对于经典类,
将使用经典查找规则. (为了试验经典类的新查找规则, 您将能够明确指定不同的元类.)
我们还将提供一个工具来分析类层次结构, 来查找受方法解析顺序更改影响的方法.

XXX 另一种解释新 MRO 动机的方法, 由于 Damian Conway: 如果在尚未探索的派生类中定义它
(使用旧的搜索顺序), 则永远不会使用基类中定义的方法.


XXX To be done
==============

本 PEP 中将讨论的其他主题:

- 向后兼容性问题

- 类方法和静态方法

- 共同方法和 ``super()``

- 类型对象槽 (tp_foo) 和特殊方法 (``__foo__``) 之间的映射
  (实际上, 这可能属于 PEP 252)

- 内置类型的内置名称 (object, int, str, list 等)

- ``__dict__`` 和 ``__dictoffset__``

- ``__slots__``

- ``HEAPTYPE`` 标志位

- GC 支持

- 所有新功能的 API 文档

- 如何使用 ``__new__``

- 编写元类 (使用 ``mro()`` 等)

- 高级用户概述

open issues
-----------

- 我们需要 ``__del__`` 吗?

- 分配给 ``__dict__``, ``__bases__``

- 不一致的命名
  (例如 tp_dealloc/tp_new/tp_init/tp_alloc/tp_free)

- 为 '字典' 添加内置别名 'dict'?

- 当 dict/list 等的子类传递给系统函数时, 并不总是使用 ``__getitem__`` 覆盖 (等)


Implementation
==============

这个 PEP (以及 PEP 252) 的原型实现可以从 CVS 以及 Python 2.2 alpha 和 beta 版本系列中获得.
有关此处描述的功能的一些示例, 请参阅文件 Lib/test/test_descr.py 和扩展模块 Modules/xxsubtype.c.


References
==========

.. [1] "放置元件到工作中", 作者: Ira R. Forman and Scott
       H. Danforth, Addison-Wesley 1999.
       (http://www.aw.com/product/0,2627,0201433052,00.html)


Copyright
=========

This document has been placed in the public domain.

..  
   Local Variables:  
   mode: indented-text  
   indent-tabs-mode: nil  
   End:  
